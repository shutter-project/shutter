#! /usr/bin/perl

###################################################
#
#  Copyright (C) Mario Kemper 2008 - 2009 <mario.kemper@googlemail.com>
#
#  This file is part of GScrot.
#
#  GScrot is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  GScrot is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with GScrot; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
###################################################

#modules
#--------------------------------------
use utf8;
use strict;
use warnings;

#GConf - used for metacity keybindings
use Gnome2::GConf;

#Image operations
use Image::Magick();

#File operations
use File::Copy;
use File::Basename;
use File::MimeInfo::Applications;
use File::Temp qw/ tempfile tempdir /;
use IO::File;

#GnomeVFS
use Gnome2::VFS '-init';

#Gtk2
use Gtk2 '-init';
use Gtk2::Gdk::Keysyms;
use Gtk2::Pango;

#Gettext and filename parsing
use POSIX qw/setlocale strftime/;
use Locale::gettext;

#handle upload responses properly
use HTTP::Status;

#load and save settings
use XML::Simple;

#timing issues
use Time::HiRes qw/usleep/;

#internal use
use FindBin '$Bin';
use Data::Dumper;

#--------------------------------------

#define constants
#--------------------------------------
use constant TRUE                => 1;
use constant FALSE               => 0;
use constant REV                 => "Rev.330";
use constant PPA_VERSION         => "ppa1";
use constant GSCROT_NAME         => "Shutter";
use constant GSCROT_VERSION      => "v0.70";
use constant GSCROT_VERSION_FULL => REV . " - " . PPA_VERSION;

#--------------------------------------

#configure path settings
#--------------------------------------
$Bin =~ m/(.*)\//;
my $gscrot_root = $1;
my $gscrot_path = $Bin . "/gscrot";
$ENV{'GSCROT_ROOT'} = $gscrot_root;    #used by some plugins

#--------------------------------------

#load modules at custom path at runtime
#--------------------------------------
require lib;
import lib "$gscrot_root/share/gscrot/resources/modules";

#proc (Thanks to Michael Schilli)
require Proc::Simple;

#gscrot app classes
require GScrot::App::Common;
require GScrot::App::SimpleDialogs;
require GScrot::App::HelperFunctions;
require GScrot::App::Menu;
require GScrot::App::Toolbar;

#drawing classes
require GScrot::Draw::DrawingTool;

#screenshot classes
require GScrot::Screenshot::SelectorAdvanced;
require GScrot::Screenshot::SelectorSimple;
require GScrot::Screenshot::Workspace;
require GScrot::Screenshot::Web;
require GScrot::Screenshot::Window;

#upload classes
require GScrot::Upload::ImageBanana;
require GScrot::Upload::UbuntuPics;
require GScrot::Upload::ImageShack;
require GScrot::Upload::FTP;

#--------------------------------------

#main window
#--------------------------------------
my $window = Gtk2::Window->new('toplevel');

#--------------------------------------

#create app objects
#--------------------------------------
my $gscrot_common = GScrot::App::Common->new($gscrot_root);
$gscrot_common->set_mainwindow($window);
my $gscrot_hfunct = GScrot::App::HelperFunctions->new($gscrot_common);
my $gscrot_menu   = GScrot::App::Menu->new($gscrot_common);
my $gscrot_tool   = GScrot::App::Toolbar->new($gscrot_common);
my $gscrot_dialog = GScrot::App::SimpleDialogs->new($window);

#--------------------------------------

#Clipboard
my $clipboard = Gtk2::Clipboard->get( Gtk2::Gdk->SELECTION_CLIPBOARD );

#Gettext
my $d = $gscrot_common->get_gettext;

#Page Setup
my $pagesetup = undef;

#Tooltips
my $tooltips = $gscrot_common->get_tooltips;

#optional components
#--------------------------------------
my $gnome_web_photo = TRUE;
my $gtkimageview    = TRUE;
my $goocanvas       = TRUE;
&fct_init_optional;

#--------------------------------------

#data structures
#--------------------------------------
my %gm_programs;    #hash to store program infos
my %plugins;        #hash to store plugin infos
my %accounts;       #hash to store account infos
my %settings;       #hash to store settings
&fct_init;
&fct_init_framework_versions;
&fct_check_installed_programs;
&fct_load_accounts;

#--------------------------------------

#signal-handler
$SIG{RTMIN} = sub { &evt_take_screenshot( 'global_keybinding', 'select' ) };
$SIG{USR1}  = sub { &evt_take_screenshot( 'global_keybinding', 'raw' ) };
$SIG{USR2}  = sub { &evt_take_screenshot( 'global_keybinding', 'window' ) };
$SIG{RTMAX} = sub { &evt_take_screenshot( 'global_keybinding', 'section' ) };

#hash of screenshots during session
my %session_screens;
my %session_start_screen;

#main window gui
#--------------------------------------
$window->set_title(GSCROT_NAME);
$window->set_default_icon( Gtk2::Gdk::Pixbuf->new_from_file_at_scale( "$gscrot_root/share/pixmaps/gscrot.svg", 100, 100, TRUE ) );
$window->signal_connect( 'delete-event' => \&evt_delete_window );
$window->set_border_width(0);
$window->set_resizable(TRUE);
$window->set_focus_on_map(TRUE);

$window->set_position('center');
$window->set_default_size( 650, 500 );
$window->set_size_request( -1, 450 );

#TRAY ICON
my $icon                 = undef;
my $current_profile_indx = 0;
my $is_in_tray           = TRUE;

#SESSION NOTEBOOK
my $notebook = Gtk2::Notebook->new;
$notebook = &fct_create_session_notebook;

#STATUSBAR
my $statusbar = Gtk2::Statusbar->new;

#arrange settings in notebook
my $notebook_settings = Gtk2::Notebook->new;
my $settings_dialog   = Gtk2::Dialog->new(
	GSCROT_NAME . " - " . $gscrot_common->get_gettext->get("Preferences"),
	$window,
	[qw/modal destroy-with-parent/],
	'gtk-close' => 'close'
);
$settings_dialog->set_has_separator(FALSE);

my $vbox = Gtk2::VBox->new( FALSE, 0 );
$window->add($vbox);

#attach signal handlers to subroutines and pack menu
#--------------------------------------
$vbox->pack_start( $gscrot_menu->create_menu, FALSE, TRUE, 0 );

$gscrot_menu->{_menuitem_open}->signal_connect( 'activate', \&evt_open, 'menu_open' );
$gscrot_menu->{_menuitem_selection}->signal_connect( 'activate', \&evt_take_screenshot, 'select' );
$gscrot_menu->{_menuitem_full}->signal_connect( 'activate', \&evt_take_screenshot, 'raw' );
$gscrot_menu->{_menuitem_window}->signal_connect( 'activate', \&evt_take_screenshot, 'window' );
$gscrot_menu->{_menuitem_section}->signal_connect( 'activate', \&evt_take_screenshot, 'section' );
$gscrot_menu->{_menuitem_web}->signal_connect( 'activate', \&evt_take_screenshot, 'web' );
$gscrot_menu->{_menuitem_save_as}->signal_connect( 'activate', \&evt_save_as, 'menu_save_as' );
$gscrot_menu->{_menuitem_print}->signal_connect( 'activate', \&fct_print, 'menu_print' );
$gscrot_menu->{_menuitem_pagesetup}->signal_connect( 'activate', \&evt_page_setup, 'menu_pagesetup' );
$gscrot_menu->{_menuitem_close}->signal_connect( 'activate', sub { &fct_remove(undef); }, 'menu_close' );
$gscrot_menu->{_menuitem_close_all}->signal_connect( 'activate', sub { &fct_remove_all(); }, 'menu_close_all' );
$gscrot_menu->{_menuitem_quit}->signal_connect( 'activate', \&evt_delete_window, 'menu_quit' );

$gscrot_menu->{_menuitem_copy}->signal_connect( 'activate', \&fct_clipboard );
$gscrot_menu->{_menuitem_trash}->signal_connect( 'activate', \&fct_delete );
$gscrot_menu->{_menuitem_settings}->signal_connect( 'activate', \&evt_show_settings, 'exp_settings_menu' );

$gscrot_menu->{_menuitem_reopen}->set_submenu(&fct_ret_program_menu);
$gscrot_menu->{_menuitem_rename}->signal_connect( 'activate', \&fct_rename );
$gscrot_menu->{_menuitem_upload}->signal_connect( 'activate', \&fct_upload );
$gscrot_menu->{_menuitem_draw}->signal_connect( 'activate', \&fct_draw );
$gscrot_menu->{_menuitem_plugin}->signal_connect( 'activate', \&fct_plugin );

$gscrot_menu->{_menuitem_back}->signal_connect( 'activate', \&evt_navigate, 'previous' );
$gscrot_menu->{_menuitem_forward}->signal_connect( 'activate', \&evt_navigate, 'forward' );
$gscrot_menu->{_menuitem_first}->signal_connect( 'activate', \&evt_navigate, 'first' );
$gscrot_menu->{_menuitem_last}->signal_connect( 'activate', \&evt_navigate, 'last' );
$gscrot_menu->{_menuitem_question}->signal_connect( 'activate', \&evt_question, $window );
$gscrot_menu->{_menuitem_translate}->signal_connect( 'activate', \&evt_translate, $window );
$gscrot_menu->{_menuitem_bug}->signal_connect( 'activate', \&evt_bug, $window );
$gscrot_menu->{_menuitem_about}->signal_connect( 'activate', \&evt_about, $window );

#--------------------------------------

#attach signal handlers to subroutines and pack toolbar
#--------------------------------------
my $handlebox = Gtk2::HandleBox->new;
$handlebox->add( $gscrot_tool->create_toolbar );
$vbox->pack_start( $handlebox, FALSE, TRUE, 0 );

my ( $tool_advanced, $tool_simple ) = undef;
my $zoom_active = undef;
my ( $zoom_size1, $zoom_size2, $zoom_size3 ) = undef;
$gscrot_tool->{_select}->set_menu(&fct_ret_sel_menu);
$gscrot_tool->{_select}->signal_connect( 'clicked' => \&evt_take_screenshot, 'select' );

my $current_monitor_active = undef;
$gscrot_tool->{_full}->signal_connect( 'clicked' => \&evt_take_screenshot, 'raw' );
$gscrot_tool->{_full}->set_menu( &fct_ret_workspace_menu(TRUE) );
$gscrot_tool->{_full}->signal_connect( 'show-menu' => sub { &fct_ret_workspace_menu(FALSE) } );

$gscrot_tool->{_window}->signal_connect( 'clicked' => \&evt_take_screenshot, 'window' );
$gscrot_tool->{_window}->set_menu(&fct_ret_window_menu);
$gscrot_tool->{_window}->signal_connect( 'show-menu' => \&fct_ret_window_menu );

$gscrot_tool->{_section}->signal_connect( 'clicked' => \&evt_take_screenshot, 'section' );

$gscrot_tool->{_web}->signal_connect( 'clicked' => \&evt_take_screenshot, 'web' );
$gscrot_tool->{_web}->set_menu(&fct_ret_web_menu);
$gscrot_tool->{_web}->signal_connect( 'show-menu' => \&fct_ret_web_menu );

#--------------------------------------

#trayicon
#--------------------------------------
#command line param set to disable tray icon?
unless ( $gscrot_common->get_disable_systray ) {

	if ( Gtk2->CHECK_VERSION( 2, 10, 0 ) ) {
		$icon = Gtk2::StatusIcon->new();
		$icon->set_from_file("$gscrot_root/share/pixmaps/gscrot.svg");
		$icon->set_visible(1);
		$icon->signal_connect(
			'popup-menu' => sub { &evt_show_systray_statusicon; },
			$icon
		);
		$icon->signal_connect(
			'activate' => sub {
				&evt_activate_systray_statusicon;
				$icon;
			},
			$icon
		);
		$icon->set_tooltip( GSCROT_NAME . " " . GSCROT_VERSION );
	} else {
		require Gtk2::TrayIcon;
		$icon = Gtk2::Image->new_from_pixbuf( Gtk2::Gdk::Pixbuf->new_from_file_at_size( "$gscrot_root/share/pixmaps/gscrot.svg", 24, 24 ) );
		my $eventbox = Gtk2::EventBox->new;
		$eventbox->add($icon);
		my $tray = Gtk2::TrayIcon->new('gscrot TrayIcon');
		$tray->add($eventbox);
		$tooltips->set_tip( $tray, GSCROT_NAME . " " . GSCROT_VERSION );
		$eventbox->signal_connect( 'button_release_event', \&evt_show_systray );
		$tray->show_all;
	}

}

#--------------------------------------

#settings
#--------------------------------------

my $vbox_settings       = Gtk2::VBox->new( FALSE, 12 );
my $hbox_settings       = Gtk2::HBox->new( FALSE, 12 );
my $vbox_basic          = Gtk2::VBox->new( FALSE, 12 );
my $vbox_extras         = Gtk2::VBox->new( FALSE, 12 );
my $vbox_behavior       = Gtk2::VBox->new( FALSE, 12 );
my $vbox_plugins        = Gtk2::VBox->new( FALSE, 12 );
my $vbox_accounts       = Gtk2::VBox->new( FALSE, 12 );
my $file_vbox           = Gtk2::VBox->new( FALSE, 0 );
my $save_vbox           = Gtk2::VBox->new( FALSE, 0 );
my $behavior_vbox       = Gtk2::VBox->new( FALSE, 0 );
my $behavior_hbox1      = Gtk2::HBox->new( FALSE, 0 );
my $behavior_hbox2      = Gtk2::HBox->new( FALSE, 0 );
my $behavior_hbox3      = Gtk2::HBox->new( FALSE, 0 );
my $behavior_hbox4      = Gtk2::HBox->new( FALSE, 0 );
my $keybinding_vbox     = Gtk2::VBox->new( FALSE, 0 );
my $keybinding_mode_box = Gtk2::HBox->new( TRUE,  0 );
my $actions_vbox        = Gtk2::VBox->new( FALSE, 0 );
my $capture_vbox        = Gtk2::VBox->new( FALSE, 0 );
my $effects_vbox        = Gtk2::VBox->new( FALSE, 0 );
my $accounts_hbox       = Gtk2::HBox->new( FALSE, 0 );
my $accounts_vbox       = Gtk2::VBox->new( FALSE, 0 );
my $ftp_hbox1           = Gtk2::HBox->new( FALSE, 0 );
my $ftp_hbox2           = Gtk2::HBox->new( FALSE, 0 );
my $ftp_hbox3           = Gtk2::HBox->new( FALSE, 0 );
my $ftp_hbox4           = Gtk2::HBox->new( FALSE, 0 );
my $ftp_vbox            = Gtk2::VBox->new( FALSE, 0 );
my $profiles_box        = Gtk2::HBox->new( FALSE, 0 );
my $scale_box           = Gtk2::HBox->new( FALSE, 0 );
my $delay_box           = Gtk2::HBox->new( FALSE, 0 );
my $delay_box2          = Gtk2::HBox->new( FALSE, 0 );
my $thumbnail_box       = Gtk2::HBox->new( FALSE, 0 );
my $thumbnail_box2      = Gtk2::HBox->new( FALSE, 0 );
my $filename_box        = Gtk2::HBox->new( FALSE, 0 );
my $progname_box        = Gtk2::HBox->new( FALSE, 0 );
my $progname_box2       = Gtk2::HBox->new( FALSE, 0 );
my $im_colors_box       = Gtk2::HBox->new( FALSE, 0 );
my $im_colors_box2      = Gtk2::HBox->new( FALSE, 0 );
my $filetype_box        = Gtk2::HBox->new( FALSE, 0 );
my $saveDir_box         = Gtk2::HBox->new( FALSE, 0 );
my $key_box             = Gtk2::HBox->new( FALSE, 0 );
my $key_box2            = Gtk2::HBox->new( FALSE, 0 );
my $key_sel_box         = Gtk2::HBox->new( FALSE, 0 );
my $key_sel_box2        = Gtk2::HBox->new( FALSE, 0 );
my $border_box          = Gtk2::HBox->new( FALSE, 0 );
my $cursor_box          = Gtk2::HBox->new( FALSE, 0 );

my $profiles_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Profile") . ":" );

#load settings
#--------------------------------------
my $settings_xml = &fct_load_settings( "start", "start" );

#load last profile
if ( defined $settings_xml->{'general'}->{'last_profile'} ) {
	if ( $settings_xml->{'general'}->{'last_profile'} != -1 ) {
		$settings_xml = &fct_load_settings( "start", "start", $settings_xml->{'general'}->{'last_profile_name'} );
	}
}

#--------------------------------------

my $combobox_settings_profiles = Gtk2::ComboBox->new_text;
my @saved_profiles             = glob("$ENV{'HOME'}/.gscrot/profiles/*.xml");
my @current_profiles;
my $current_index = 0;
foreach ( sort @saved_profiles ) {
	utf8::decode $_;
	next
		if $_ =~ /\_accounts.xml/;    #accounts file - we are looking for "real" profiles
	$_ =~ /.*\/(.*)\.xml/;            #get profiles name
	my $last_profile_name = $1;
	$combobox_settings_profiles->append_text($last_profile_name);

	#set active profile
	if ( exists $settings_xml->{'general'}->{'last_profile_name'} ) {
		if ( $settings_xml->{'general'}->{'last_profile_name'} eq $last_profile_name ) {
			$combobox_settings_profiles->set_active($current_index);
			$current_profile_indx = $current_index;
		}
	}

	push( @current_profiles, $last_profile_name );
	$current_index++;
}
$tooltips->set_tip( $combobox_settings_profiles, $gscrot_common->get_gettext->get("Choose a profile") );

#set 0 if nothing is selected yet
if ( !$combobox_settings_profiles->get_active_text ) {
	$combobox_settings_profiles->set_active(0);
	$current_profile_indx = 0;
}

#populate quick selector as well
$gscrot_menu->{_menuitem_quicks}->set_submenu( fct_ret_profile_menu( $combobox_settings_profiles, \@current_profiles ) );

my $button_profile_save = Gtk2::Button->new;
$button_profile_save->signal_connect(
	'clicked' => sub {
		my $widget = shift;
		&evt_save_profile( $widget, $combobox_settings_profiles, \@current_profiles );
	}
);
$button_profile_save->set_image( Gtk2::Image->new_from_stock( 'gtk-save', 'button' ) );
$tooltips->set_tip( $button_profile_save, $gscrot_common->get_gettext->get("Save configuration as profile") );

my $button_profile_delete = Gtk2::Button->new;
$button_profile_delete->signal_connect(
	'clicked' => sub {
		my $widget = shift;
		&evt_delete_profile( $widget, $combobox_settings_profiles, \@current_profiles );
	}
);
$button_profile_delete->set_image( Gtk2::Image->new_from_stock( 'gtk-delete', 'button' ) );
$tooltips->set_tip( $button_profile_delete, $gscrot_common->get_gettext->get("Delete profile") );
my $button_profile_apply = Gtk2::Button->new;
$button_profile_apply->signal_connect(
	'clicked' => sub {
		my $widget = shift;
		&evt_apply_profile( $widget, $combobox_settings_profiles, \@current_profiles );
	}
);
$button_profile_apply->set_image( Gtk2::Image->new_from_stock( 'gtk-apply', 'button' ) );
$tooltips->set_tip( $button_profile_apply, $gscrot_common->get_gettext->get("Set profile for current configuration") );

my $file_frame_label = Gtk2::Label->new;
$file_frame_label->set_markup( "<b>" . $gscrot_common->get_gettext->get("Image format") . "</b>" );

my $file_frame = Gtk2::Frame->new();
$file_frame->set_label_widget($file_frame_label);
$file_frame->set_shadow_type('none');

my $save_frame_label = Gtk2::Label->new;
$save_frame_label->set_markup( "<b>" . $gscrot_common->get_gettext->get("Save") . "</b>" );

my $save_frame = Gtk2::Frame->new();
$save_frame->set_label_widget($save_frame_label);
$save_frame->set_shadow_type('none');

my $behavior_frame_label = Gtk2::Label->new;
$behavior_frame_label->set_markup( "<b>" . $gscrot_common->get_gettext->get("Behavior") . "</b>" );

my $behavior_frame = Gtk2::Frame->new();
$behavior_frame->set_label_widget($behavior_frame_label);
$behavior_frame->set_shadow_type('none');

my $keybinding_frame_label = Gtk2::Label->new;
$keybinding_frame_label->set_markup( "<b>" . $gscrot_common->get_gettext->get("Gnome-Keybinding") . "</b>" );

my $keybinding_frame = Gtk2::Frame->new();
$keybinding_frame->set_label_widget($keybinding_frame_label);
$keybinding_frame->set_shadow_type('none');

my $actions_frame_label = Gtk2::Label->new;
$actions_frame_label->set_markup( "<b>" . $gscrot_common->get_gettext->get("Actions") . "</b>" );

my $actions_frame = Gtk2::Frame->new();
$actions_frame->set_label_widget($actions_frame_label);
$actions_frame->set_shadow_type('none');

my $capture_frame_label = Gtk2::Label->new;
$capture_frame_label->set_markup( "<b>" . $gscrot_common->get_gettext->get("Capture") . "</b>" );

my $capture_frame = Gtk2::Frame->new();
$capture_frame->set_label_widget($capture_frame_label);
$capture_frame->set_shadow_type('none');

my $accounts_frame_label = Gtk2::Label->new;
$accounts_frame_label->set_markup( "<b>" . $gscrot_common->get_gettext->get("Accounts") . "</b>" );

my $accounts_frame = Gtk2::Frame->new();
$accounts_frame->set_label_widget($accounts_frame_label);
$accounts_frame->set_shadow_type('none');

my $ftp_frame_label = Gtk2::Label->new;
$ftp_frame_label->set_markup( "<b>" . $gscrot_common->get_gettext->get("File Transfer Protocol (FTP)") . "</b>" );

my $ftp_frame = Gtk2::Frame->new();
$ftp_frame->set_label_widget($ftp_frame_label);
$ftp_frame->set_shadow_type('none');

#delay
my $delay_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Delay") . ":" );
my $delay = Gtk2::HScale->new_with_range( 1, 10, 1 );
$delay->signal_connect(
	'value-changed' => \&evt_value_changed,
	'delay_changed'
);
$delay->set_value_pos('right');

if ( defined $settings_xml->{'general'}->{'delay'} ) {
	$delay->set_value( $settings_xml->{'general'}->{'delay'} );
} else {
	$delay->set_value(0);
}
my $delay_active = Gtk2::CheckButton->new;
$delay_active->signal_connect(
	'toggled' => \&evt_value_changed,
	'delay_toggled'
);
$delay_active->set_active(TRUE);

if ( defined $settings_xml->{'general'}->{'delay_active'} ) {
	$delay_active->set_active( $settings_xml->{'general'}->{'delay_active'} );
} else {
	$delay_active->set_active(FALSE);
}
$tooltips->set_tip( $delay,        $gscrot_common->get_gettext->get("Wait n seconds before taking a screenshot") );
$tooltips->set_tip( $delay_active, $gscrot_common->get_gettext->get("Wait n seconds before taking a screenshot") );
$tooltips->set_tip( $delay_label,  $gscrot_common->get_gettext->get("Wait n seconds before taking a screenshot") );
$delay_box->pack_start( $delay_label, FALSE, TRUE, 12 );
$delay_box2->pack_start( $delay_active, FALSE, FALSE, 0 );
$delay_box2->pack_start( $delay,        TRUE,  TRUE,  0 );
$delay_box->pack_start( $delay_box2, TRUE, TRUE, 0 );

#end - delay

#thumbnail
my $thumbnail_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Thumbnail") . ":" );
my $thumbnail = Gtk2::HScale->new_with_range( 1, 100, 1 );
$thumbnail->signal_connect(
	'value-changed' => \&evt_value_changed,
	'thumbnail_changed'
);
$thumbnail->set_value_pos('right');

if ( defined $settings_xml->{'general'}->{'thumbnail'} ) {
	$thumbnail->set_value( $settings_xml->{'general'}->{'thumbnail'} );
} else {
	$thumbnail->set_value(50);
}
my $thumbnail_active = Gtk2::CheckButton->new;
$thumbnail_active->signal_connect(
	'toggled' => \&evt_value_changed,
	'thumbnail_toggled'
);
$thumbnail_active->set_active(TRUE);

if ( defined $settings_xml->{'general'}->{'thumbnail_active'} ) {
	$thumbnail_active->set_active( $settings_xml->{'general'}->{'thumbnail_active'} );
} else {
	$thumbnail_active->set_active(FALSE);
}
$tooltips->set_tip( $thumbnail,
	$gscrot_common->get_gettext->get("Generate thumbnail too.\nselect the percentage of the original size for the thumbnail to be") );
$tooltips->set_tip( $thumbnail_active,
	$gscrot_common->get_gettext->get("Generate thumbnail too.\nselect the percentage of the original size for the thumbnail to be") );
$tooltips->set_tip( $thumbnail_label,
	$gscrot_common->get_gettext->get("Generate thumbnail too.\nselect the percentage of the original size for the thumbnail to be") );
$thumbnail_box->pack_start( $thumbnail_label, FALSE, TRUE, 12 );
$thumbnail_box2->pack_start( $thumbnail_active, FALSE, FALSE, 0 );
$thumbnail_box2->pack_start( $thumbnail,        TRUE,  TRUE,  0 );
$thumbnail_box->pack_start( $thumbnail_box2, TRUE, TRUE, 0 );

#end - thumbnail
#filename
my $filename = Gtk2::Entry->new;
if ( defined $settings_xml->{'general'}->{'filename'} ) {
	$filename->set_text( $settings_xml->{'general'}->{'filename'} );
} else {
	$filename->set_text("screenshot_\%NN");
}
my $filename_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Filename") . ":" );
$tooltips->set_tip(
	$filename,
	$gscrot_common->get_gettext->get(
		"There are several wild-cards available, like\n%Y = year\n%m = month\n%d = day\n%T = time\n\$w = width\n\$h = height\n%NN = counter"
	)
);
$tooltips->set_tip(
	$filename_label,
	$gscrot_common->get_gettext->get(
		"There are several wild-cards available, like\n%Y = year\n%m = month\n%d = day\n%T = time\n\$w = width\n\$h = height\n%NN = counter"
	)
);
$filename_box->pack_start( $filename_label, FALSE, TRUE, 12 );
$filename_box->pack_start( $filename,       TRUE,  TRUE, 0 );

#end - filename
#filetype and scale
my $scale = Gtk2::HScale->new_with_range( 0, 9, 1 );
my $scale_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Compression") . ":" );
$scale->set_value_pos('right');
$scale->set_value(1);

#we don't need a default here because it will be set through signal handling (filetype)
if ( defined $settings_xml->{'general'}->{'quality'} ) {
	$scale->set_value( $settings_xml->{'general'}->{'quality'} );
}

$tooltips->set_tip( $scale,
	$gscrot_common->get_gettext->get("Quality/Compression:\nHigh value means high size / high compression\n(depending on file format chosen)") );
$tooltips->set_tip( $scale_label,
	$gscrot_common->get_gettext->get("Quality/Compression:\nHigh value means high size / high compression\n(depending on file format chosen)") );
$scale_box->pack_start( $scale_label, FALSE, TRUE, 12 );
$scale_box->pack_start( $scale,       TRUE,  TRUE, 0 );

#add compatile, writeable file types
my $combobox_type = Gtk2::ComboBox->new_text;
my ( $int_png, $int_jpeg, $int_bmp ) = ( 0, 0, 0 );
my $format_counter = 0;
foreach ( Gtk2::Gdk::Pixbuf->get_formats ) {
	if (   $_->{name} eq "jpeg"
		|| $_->{name} eq "png"
		|| $_->{name} eq "bmp" )
	{
		$combobox_type->append_text( $_->{name} . " - " . $_->{description} );

		$format_counter++;

		#a little ugly here, maybe the values are in alternative order on several machine...
		#just remember the number when appending, so we can set png as default for example
		if ( $_->{name} eq "jpeg" ) {
			$int_jpeg = $format_counter;
		} elsif ( $_->{name} eq "png" ) {
			$int_png = $format_counter;
		} elsif ( $_->{name} eq "bmp" ) {
			$int_bmp = $format_counter;
		}
	}
}
$combobox_type->signal_connect( 'changed' => \&evt_value_changed, 'type_changed' );

if ( defined $settings_xml->{'general'}->{'filetype'} ) {
	$combobox_type->set_active( $settings_xml->{'general'}->{'filetype'} );
} else {

	#we will try to set a default value in this order
	foreach ( @{ [ $int_png, $int_jpeg, $int_bmp ] } ) {
		if ( $_ > 0 ) {
			$combobox_type->set_active( $_ - 1 );
			last;
		}
	}

}

my $filetype_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Image format") . ":" );
$tooltips->set_tip( $combobox_type,  $gscrot_common->get_gettext->get("Select a file format") );
$tooltips->set_tip( $filetype_label, $gscrot_common->get_gettext->get("Select a file format") );
$filetype_box->pack_start( $filetype_label, FALSE, TRUE, 12 );
$filetype_box->pack_start( $combobox_type,  TRUE,  TRUE, 0 );

#end - filetype and scale
#saveDir
my $saveDir_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Directory") . ":" );
my $saveDir_button = Gtk2::FileChooserButton->new( "GScrot - " . $gscrot_common->get_gettext->get("Choose folder"), 'select-folder' );
if ( defined $settings_xml->{'general'}->{'folder'} ) {
	$saveDir_button->set_filename( $settings_xml->{'general'}->{'folder'} );
} else {
	$saveDir_button->set_filename( $ENV{'HOME'} );
}

$tooltips->set_tip( $saveDir_button, $gscrot_common->get_gettext->get("Your screenshots will be saved\nto this directory") );
$tooltips->set_tip( $saveDir_label,  $gscrot_common->get_gettext->get("Your screenshots will be saved\nto this directory") );
$saveDir_box->pack_start( $saveDir_label,  FALSE, TRUE, 12 );
$saveDir_box->pack_start( $saveDir_button, TRUE,  TRUE, 0 );

#end - saveDir
#behavior
my $capture_key = Gtk2::Entry->new;
if ( defined $settings_xml->{'general'}->{'capture_key'} ) {
	$capture_key->set_text( $settings_xml->{'general'}->{'capture_key'} );
} else {
	$capture_key->set_text("Print");
}
my $capture_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Capture") . ":" );
$tooltips->set_tip(
	$capture_key,
	$gscrot_common->get_gettext->get(
		"Configure global keybinding for capture\nThe format looks like \"<Control>a\" or \"<Shift><Alt>F1\". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as \"<Ctl>\" and \"<Ctrl>\". If you set the option to the special string \"disabled\", then there will be no keybinding for this action. "
	)
);
$tooltips->set_tip(
	$capture_label,
	$gscrot_common->get_gettext->get(
		"Configure global keybinding for capture\nThe format looks like \"<Control>a\" or \"<Shift><Alt>F1\". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as \"<Ctl>\" and \"<Ctrl>\". If you set the option to the special string \"disabled\", then there will be no keybinding for this action. "
	)
);
my $capture_sel_key = Gtk2::Entry->new;

if ( defined $settings_xml->{'general'}->{'capture_sel_key'} ) {
	$capture_sel_key->set_text( $settings_xml->{'general'}->{'capture_sel_key'} );
} else {
	$capture_sel_key->set_text("<Alt>Print");
}

my $capture_sel_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Capture with selection") . ":" );
$tooltips->set_tip(
	$capture_sel_key,
	$gscrot_common->get_gettext->get(
		"Configure global keybinding for capture with selection\nThe format looks like \"<Control>a\" or \"<Shift><Alt>F1\". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as \"<Ctl>\" and \"<Ctrl>\". If you set the option to the special string \"disabled\", then there will be no keybinding for this action. "
	)
);
$tooltips->set_tip(
	$capture_sel_label,
	$gscrot_common->get_gettext->get(
		"Configure global keybinding for capture with selection\nThe format looks like \"<Control>a\" or \"<Shift><Alt>F1\". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as \"<Ctl>\" and \"<Ctrl>\". If you set the option to the special string \"disabled\", then there will be no keybinding for this action. "
	)
);

#keybinding_mode
my $combobox_keybinding_mode = Gtk2::ComboBox->new_text;
$combobox_keybinding_mode->insert_text( 0, $gscrot_common->get_gettext->get("Selection") );
$combobox_keybinding_mode->insert_text( 1, $gscrot_common->get_gettext->get("Window") );
$combobox_keybinding_mode->insert_text( 2, $gscrot_common->get_gettext->get("Section") );

if ( defined $settings_xml->{'general'}->{'keybinding_mode'} ) {
	$combobox_keybinding_mode->set_active( $settings_xml->{'general'}->{'keybinding_mode'} );
} else {
	$combobox_keybinding_mode->set_active(1);
}
$tooltips->set_tip(
	$combobox_keybinding_mode,
	$gscrot_common->get_gettext->get(
		"Configure global keybinding for capture with selection\nThe format looks like \"<Control>a\" or \"<Shift><Alt>F1\". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as \"<Ctl>\" and \"<Ctrl>\". If you set the option to the special string \"disabled\", then there will be no keybinding for this action. "
	)
);
$combobox_keybinding_mode->signal_connect(
	'changed' => \&evt_behavior_handle,
	'keybinding_sel_toggled'
);

$keybinding_mode_box->pack_start( Gtk2::Label->new,          FALSE, FALSE, 0 );
$keybinding_mode_box->pack_start( $combobox_keybinding_mode, TRUE,  TRUE,  0 );

#keybindings
my $keybinding_active = Gtk2::CheckButton->new;
$keybinding_active->signal_connect(
	'toggled' => \&evt_behavior_handle,
	'keybinding_toggled'
);
my $keybinding_sel_active = Gtk2::CheckButton->new;
$keybinding_sel_active->signal_connect(
	'toggled' => \&evt_behavior_handle,
	'keybinding_sel_toggled'
);
$key_box->pack_start( $capture_label, FALSE, TRUE, 12 );
$key_box2->pack_start( $keybinding_active, FALSE, FALSE, 0 );
$key_box2->pack_start( $capture_key,       TRUE,  TRUE,  0 );
$key_box->pack_start( $key_box2, TRUE, TRUE, 0 );
$key_sel_box->pack_start( $capture_sel_label, FALSE, TRUE, 12 );
$key_sel_box2->pack_start( $keybinding_sel_active, FALSE, FALSE, 0 );
$key_sel_box2->pack_start( $capture_sel_key,       TRUE,  TRUE,  0 );
$key_sel_box->pack_start( $key_sel_box2, TRUE, TRUE, 0 );
$keybinding_active->set_active(TRUE);

if ( defined $settings_xml->{'general'}->{'keybinding'} ) {
	$keybinding_active->set_active( $settings_xml->{'general'}->{'keybinding'} );
} else {
	$keybinding_active->set_active(FALSE);
}
$keybinding_sel_active->set_active(TRUE);
if ( defined $settings_xml->{'general'}->{'keybinding_sel'} ) {
	$keybinding_sel_active->set_active( $settings_xml->{'general'}->{'keybinding_sel'} );
} else {
	$keybinding_sel_active->set_active(FALSE);
}
my $hide_active           = Gtk2::CheckButton->new_with_label( $gscrot_common->get_gettext->get("Autohide GScrot Window when taking a screenshot") );
my $autocopy_active       = Gtk2::CheckButton->new_with_label( $gscrot_common->get_gettext->get("Automatically copy screenshot to clipboard") );
my $close_at_close_active = Gtk2::CheckButton->new_with_label( $gscrot_common->get_gettext->get("Minimize to tray when closing main window") );
my $save_at_close_active  = Gtk2::CheckButton->new_with_label( $gscrot_common->get_gettext->get("Save settings when exiting") );
$behavior_hbox1->pack_start( $hide_active,           FALSE, TRUE, 12 );
$behavior_hbox2->pack_start( $autocopy_active,       FALSE, TRUE, 12 );
$behavior_hbox3->pack_start( $close_at_close_active, FALSE, TRUE, 12 );
$behavior_hbox4->pack_start( $save_at_close_active,  FALSE, TRUE, 12 );

$hide_active->signal_connect(
	'toggled' => \&evt_behavior_handle,
	'hide_toggled'
);

if ( defined $settings_xml->{'general'}->{'autohide'} ) {
	$hide_active->set_active( $settings_xml->{'general'}->{'autohide'} );
} else {
	$hide_active->set_active(TRUE);
}
$tooltips->set_tip( $hide_active, $gscrot_common->get_gettext->get("Automatically hide GScrot Window when taking a screenshot") );
$autocopy_active->signal_connect(
	'toggled' => \&evt_behavior_handle,
	'autocopy_toggled'
);

if ( defined $settings_xml->{'general'}->{'autocopy'} ) {
	$autocopy_active->set_active( $settings_xml->{'general'}->{'autocopy'} );
} else {
	$autocopy_active->set_active(TRUE);
}
$tooltips->set_tip( $autocopy_active, $gscrot_common->get_gettext->get("Automatically copy screenshot to clipboard") );
$close_at_close_active->signal_connect(
	'toggled' => \&evt_behavior_handle,
	'close_at_close_toggled'
);

if ( defined $settings_xml->{'general'}->{'close_at_close'} ) {
	$close_at_close_active->set_active( $settings_xml->{'general'}->{'close_at_close'} );
} else {
	$close_at_close_active->set_active(TRUE);
}
$tooltips->set_tip( $close_at_close_active, $gscrot_common->get_gettext->get("Minimize to tray when closing main window") );
$save_at_close_active->signal_connect(
	'toggled' => \&evt_behavior_handle,
	'save_at_close_toggled'
);

if ( defined $settings_xml->{'general'}->{'save_at_close'} ) {
	$save_at_close_active->set_active( $settings_xml->{'general'}->{'save_at_close'} );
} else {
	$save_at_close_active->set_active(TRUE);
}
$tooltips->set_tip( $save_at_close_active, $gscrot_common->get_gettext->get("Save settings automatically when exiting GScrot") );

#end - behavior
#program
my $model        = &fct_get_program_model;
my $progname     = Gtk2::ComboBox->new($model);
my $renderer_pix = Gtk2::CellRendererPixbuf->new;
$progname->pack_start( $renderer_pix, FALSE );
$progname->add_attribute( $renderer_pix, pixbuf => 0 );
my $renderer_text = Gtk2::CellRendererText->new;
$progname->pack_start( $renderer_text, FALSE );
$progname->add_attribute( $renderer_text, text => 1 );

#try to set the saved value
if ( defined $settings_xml->{'general'}->{'prog'} ) {
	$model->foreach( \&fct_iter_programs, $settings_xml->{'general'}->{'prog'} );
} else {
	$progname->set_active(0);
}

#nothing has been set
if ( $progname->get_active == -1 ) {
	$progname->set_active(0);
}

my $progname_active = Gtk2::CheckButton->new;
$progname_active->signal_connect(
	'toggled' => \&evt_value_changed,
	'progname_toggled'
);
if ( defined $settings_xml->{'general'}->{'prog_active'} ) {
	$progname_active->set_active( $settings_xml->{'general'}->{'prog_active'} );
} else {
	$progname_active->set_active(FALSE);
}
my $progname_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Open with") . ":" );
$tooltips->set_tip( $progname,        $gscrot_common->get_gettext->get("Open your screenshot\nwith this program after capturing") );
$tooltips->set_tip( $progname_active, $gscrot_common->get_gettext->get("Open your screenshot\nwith this program after capturing") );
$tooltips->set_tip( $progname_label,  $gscrot_common->get_gettext->get("Open your screenshot\nwith this program after capturing") );
$progname_box->pack_start( $progname_label, FALSE, TRUE, 12 );
$progname_box2->pack_start( $progname_active, FALSE, TRUE, 0 );
$progname_box2->pack_start( $progname,        TRUE,  TRUE, 0 );
$progname_box->pack_start( $progname_box2, TRUE, TRUE, 0 );

#end - program
#im_colors
my $combobox_im_colors = Gtk2::ComboBox->new_text;
$combobox_im_colors->insert_text( 0, $gscrot_common->get_gettext->get("16 colors   - (4bit) ") );
$combobox_im_colors->insert_text( 1, $gscrot_common->get_gettext->get("64 colors   - (6bit) ") );
$combobox_im_colors->insert_text( 2, $gscrot_common->get_gettext->get("256 colors  - (8bit) ") );
$combobox_im_colors->signal_connect(
	'changed' => \&evt_value_changed,
	'border_changed'
);

if ( defined $settings_xml->{'general'}->{'im_colors'} ) {
	$combobox_im_colors->set_active( $settings_xml->{'general'}->{'im_colors'} );
} else {
	$combobox_im_colors->set_active(2);
}
my $im_colors_active = Gtk2::CheckButton->new;
$im_colors_active->signal_connect(
	'toggled' => \&evt_value_changed,
	'im_colors_toggled'
);
$im_colors_active->set_active(TRUE);

if ( defined $settings_xml->{'general'}->{'im_colors_active'} ) {
	$im_colors_active->set_active( $settings_xml->{'general'}->{'im_colors_active'} );
} else {
	$im_colors_active->set_active(FALSE);
}
my $im_colors_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Reduce colors") . ":" );
$tooltips->set_tip( $combobox_im_colors, $gscrot_common->get_gettext->get("Automatically reduce colors \nafter taking a screenshot") );
$tooltips->set_tip( $im_colors_active,   $gscrot_common->get_gettext->get("Automatically reduce colors \nafter taking a screenshot") );
$tooltips->set_tip( $im_colors_label,    $gscrot_common->get_gettext->get("Automatically reduce colors \nafter taking a screenshot") );
$im_colors_box->pack_start( $im_colors_label, FALSE, TRUE, 12 );
$im_colors_box2->pack_start( $im_colors_active,   FALSE, TRUE, 0 );
$im_colors_box2->pack_start( $combobox_im_colors, TRUE,  TRUE, 0 );
$im_colors_box->pack_start( $im_colors_box2, TRUE, TRUE, 0 );

#end - colors
#border
my $combobox_border = Gtk2::ComboBox->new_text;
$combobox_border->insert_text( 1, $gscrot_common->get_gettext->get("activate") );
$combobox_border->insert_text( 0, $gscrot_common->get_gettext->get("deactivate") );
$combobox_border->signal_connect(
	'changed' => \&evt_value_changed,
	'border_changed'
);

if ( defined $settings_xml->{'general'}->{'border'} ) {
	$combobox_border->set_active( $settings_xml->{'general'}->{'border'} );
} else {
	$combobox_border->set_active(TRUE);
}
my $border_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Window border") . ":" );
$tooltips->set_tip( $combobox_border, $gscrot_common->get_gettext->get("Include wm border when selecting a window") );
$tooltips->set_tip( $border_label,    $gscrot_common->get_gettext->get("Include wm border when selecting a window") );
$border_box->pack_start( $border_label,    FALSE, TRUE, 12 );
$border_box->pack_start( $combobox_border, TRUE,  TRUE, 0 );

#end - border

#cursor
my $combobox_cursor = Gtk2::ComboBox->new_text;
$combobox_cursor->insert_text( 1, $gscrot_common->get_gettext->get("activate") );
$combobox_cursor->insert_text( 0, $gscrot_common->get_gettext->get("deactivate") );
$combobox_cursor->signal_connect(
	'changed' => \&evt_value_changed,
	'cursor_changed'
);

if ( defined $settings_xml->{'general'}->{'cursor'} ) {
	$combobox_cursor->set_active( $settings_xml->{'general'}->{'cursor'} );
} else {
	$combobox_cursor->set_active(0);
}
my $cursor_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Include cursor") . ":" );
$tooltips->set_tip( $combobox_cursor, $gscrot_common->get_gettext->get("Include cursor when taking a screenshot") );
$tooltips->set_tip( $cursor_label,    $gscrot_common->get_gettext->get("Include cursor when taking a screenshot") );
$cursor_box->pack_start( $cursor_label,    FALSE, TRUE, 12 );
$cursor_box->pack_start( $combobox_cursor, TRUE,  TRUE, 0 );

#end - cursor

#accounts
#--------------------------------------
my $accounts_model = undef;
&fct_load_accounts_tree;

my $accounts_tree = Gtk2::TreeView->new_with_model($accounts_model);
$tooltips->set_tip(
	$accounts_tree,
	$gscrot_common->get_gettext->get(
		"Entering your Accounts for specific hosting-sites is optional. If entered it will give you the same benefits as the upload on the website. If you leave these fields empty you will be able to upload to the specific hosting-partner as a guest."
	)
);

$accounts_tree->signal_connect(
	'row-activated' => \&evt_accounts,
	'row_activated'
);

&fct_set_model_accounts($accounts_tree);

#ftp uri
my $ftp_entry_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("URI") . ":" );

my $ftp_remote_entry = Gtk2::Entry->new;
if ( defined $settings_xml->{'general'}->{'ftp_uri'} ) {
	$ftp_remote_entry->set_text( $settings_xml->{'general'}->{'ftp_uri'} );
} else {
	$ftp_remote_entry->set_text("ftp://host:port/path");
}

$tooltips->set_tip( $ftp_entry_label, $gscrot_common->get_gettext->get("URI\nExample: ftp://host:port/path") );

$tooltips->set_tip( $ftp_remote_entry, $gscrot_common->get_gettext->get("URI\nExample: ftp://host:port/path") );

$ftp_hbox1->pack_start( $ftp_entry_label,  FALSE, TRUE, 12 );
$ftp_hbox1->pack_start( $ftp_remote_entry, TRUE,  TRUE, 0 );

#connection mode
my $ftp_mode_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Connection mode") . ":" );

my $ftp_mode_combo = Gtk2::ComboBox->new_text;
$ftp_mode_combo->insert_text( 0, $gscrot_common->get_gettext->get("Active mode") );
$ftp_mode_combo->insert_text( 1, $gscrot_common->get_gettext->get("Passive mode") );
if ( defined $settings_xml->{'general'}->{'ftp_mode'} ) {
	$ftp_mode_combo->set_active( $settings_xml->{'general'}->{'ftp_mode'} );
} else {
	$ftp_mode_combo->set_active(0);
}

$tooltips->set_tip( $ftp_mode_label, $gscrot_common->get_gettext->get("Connection mode") );

$tooltips->set_tip( $ftp_mode_combo, $gscrot_common->get_gettext->get("Connection mode") );

$ftp_hbox2->pack_start( $ftp_mode_label, FALSE, TRUE, 12 );
$ftp_hbox2->pack_start( $ftp_mode_combo, TRUE,  TRUE, 0 );

#username
my $ftp_username_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Username") . ":" );

my $ftp_username_entry = Gtk2::Entry->new;
if ( defined $settings_xml->{'general'}->{'ftp_username'} ) {
	$ftp_username_entry->set_text( $settings_xml->{'general'}->{'ftp_username'} );
} else {
	$ftp_username_entry->set_text("");
}

$tooltips->set_tip( $ftp_username_label, $gscrot_common->get_gettext->get("Username") );

$tooltips->set_tip( $ftp_username_entry, $gscrot_common->get_gettext->get("Username") );

$ftp_hbox3->pack_start( $ftp_username_label, FALSE, TRUE, 12 );
$ftp_hbox3->pack_start( $ftp_username_entry, TRUE,  TRUE, 0 );

#password
my $ftp_password_label = Gtk2::Label->new( $gscrot_common->get_gettext->get("Password") . ":" );

my $ftp_password_entry = Gtk2::Entry->new;
$ftp_password_entry->set_invisible_char("*");
$ftp_password_entry->set_visibility(FALSE);
if ( defined $settings_xml->{'general'}->{'ftp_password'} ) {
	$ftp_password_entry->set_text( $settings_xml->{'general'}->{'ftp_password'} );
} else {
	$ftp_password_entry->set_text("");
}

$tooltips->set_tip( $ftp_password_label, $gscrot_common->get_gettext->get("Password") );

$tooltips->set_tip( $ftp_password_entry, $gscrot_common->get_gettext->get("Password") );

$ftp_hbox4->pack_start( $ftp_password_label, FALSE, TRUE, 12 );
$ftp_hbox4->pack_start( $ftp_password_entry, TRUE,  TRUE, 0 );

#--------------------------------------

#plugins
#--------------------------------------
my $effects_model = undef;
&fct_load_plugin_tree;

my $effects_tree = Gtk2::TreeView->new_with_model($effects_model);
$effects_tree->signal_connect(
	'row-activated' => \&evt_plugins,
	'row_activated'
);

&fct_set_model_plugins($effects_tree);

#--------------------------------------

#packing
#--------------------------------------

#settings main tab
my $label_basic = Gtk2::Label->new;
$label_basic->set_markup( $gscrot_common->get_gettext->get("Main") );

$file_vbox->pack_start( $scale_box,    TRUE,  TRUE, 3 );
$file_vbox->pack_start( $filetype_box, FALSE, TRUE, 3 );
$file_frame->add($file_vbox);

$save_vbox->pack_start( $filename_box, TRUE,  TRUE, 3 );
$save_vbox->pack_start( $saveDir_box,  FALSE, TRUE, 3 );
$save_frame->add($save_vbox);

#all labels = one size
$scale_label->set_alignment( 0, 0.5 );
$filetype_label->set_alignment( 0, 0.5 );
$filename_label->set_alignment( 0, 0.5 );
$saveDir_label->set_alignment( 0, 0.5 );

my $sg_main = Gtk2::SizeGroup->new('horizontal');
$sg_main->add_widget($scale_label);
$sg_main->add_widget($filetype_label);
$sg_main->add_widget($filename_label);
$sg_main->add_widget($saveDir_label);

$vbox_basic->pack_start( $file_frame, FALSE, TRUE, 3 );
$vbox_basic->pack_start( $save_frame, FALSE, TRUE, 3 );
$vbox_basic->set_border_width(5);

#settings advanced tab
my $label_extras = Gtk2::Label->new;
$label_extras->set_markup( $gscrot_common->get_gettext->get("Advanced") );

$actions_vbox->pack_start( $progname_box,  FALSE, TRUE, 3 );
$actions_vbox->pack_start( $im_colors_box, FALSE, TRUE, 3 );
$actions_vbox->pack_start( $thumbnail_box, FALSE, TRUE, 3 );
$actions_frame->add($actions_vbox);

$capture_vbox->pack_start( $delay_box,  FALSE, TRUE, 3 );
$capture_vbox->pack_start( $border_box, FALSE, TRUE, 3 );
$capture_vbox->pack_start( $cursor_box, FALSE, TRUE, 3 );
$capture_frame->add($capture_vbox);

#all labels = one size
$progname_label->set_alignment( 0, 0.5 );
$im_colors_label->set_alignment( 0, 0.5 );
$thumbnail_label->set_alignment( 0, 0.5 );
$delay_label->set_alignment( 0, 0.5 );
$border_label->set_alignment( 0, 0.5 );
$cursor_label->set_alignment( 0, 0.5 );

my $sg_adv = Gtk2::SizeGroup->new('horizontal');
$sg_adv->add_widget($progname_label);
$sg_adv->add_widget($im_colors_label);
$sg_adv->add_widget($thumbnail_label);
$sg_adv->add_widget($delay_label);
$sg_adv->add_widget($border_label);
$sg_adv->add_widget($cursor_label);

$vbox_extras->pack_start( $actions_frame, FALSE, TRUE, 3 );
$vbox_extras->pack_start( $capture_frame, FALSE, TRUE, 3 );
$vbox_extras->set_border_width(5);

#settings behavior tab
my $label_behavior = Gtk2::Label->new;
$label_behavior->set_markup( $gscrot_common->get_gettext->get("Behavior") );

$behavior_vbox->pack_start( $behavior_hbox1, TRUE, TRUE, 3 );
$behavior_vbox->pack_start( $behavior_hbox2, TRUE, TRUE, 3 );
$behavior_vbox->pack_start( $behavior_hbox3, TRUE, TRUE, 3 );
$behavior_vbox->pack_start( $behavior_hbox4, TRUE, TRUE, 3 );
$behavior_frame->add($behavior_vbox);

$keybinding_vbox->pack_start( $key_box,             FALSE, TRUE, 3 );
$keybinding_vbox->pack_start( $key_sel_box,         FALSE, TRUE, 3 );
$keybinding_vbox->pack_start( $keybinding_mode_box, FALSE, TRUE, 3 );
$keybinding_frame->add($keybinding_vbox);

#all labels = one size
$capture_label->set_alignment( 0, 0.5 );
$capture_sel_label->set_alignment( 0, 0.5 );

my $sg_behav = Gtk2::SizeGroup->new('horizontal');
$sg_behav->add_widget($capture_label);
$sg_behav->add_widget($capture_sel_label);

$vbox_behavior->pack_start( $behavior_frame,   FALSE, TRUE, 3 );
$vbox_behavior->pack_start( $keybinding_frame, FALSE, TRUE, 3 );
$vbox_behavior->set_border_width(5);

#settings upload tab
my $label_accounts = Gtk2::Label->new;
$label_accounts->set_markup( $gscrot_common->get_gettext->get("Upload") );

my $scrolled_accounts_window = Gtk2::ScrolledWindow->new;
$scrolled_accounts_window->set_policy( 'automatic', 'automatic' );
$scrolled_accounts_window->set_shadow_type('in');
$scrolled_accounts_window->add($accounts_tree);
$accounts_hbox->pack_start( $scrolled_accounts_window, TRUE, TRUE, 3 );
$accounts_vbox->pack_start( $accounts_hbox,            TRUE, TRUE, 3 );
$accounts_frame->add($accounts_vbox);

$ftp_vbox->pack_start( $ftp_hbox1, FALSE, TRUE, 3 );
$ftp_vbox->pack_start( $ftp_hbox2, FALSE, TRUE, 3 );
$ftp_vbox->pack_start( $ftp_hbox3, FALSE, TRUE, 3 );
$ftp_vbox->pack_start( $ftp_hbox4, FALSE, TRUE, 3 );
$ftp_frame->add($ftp_vbox);

#all labels = one size
$ftp_entry_label->set_alignment( 0, 0.5 );
$ftp_mode_label->set_alignment( 0, 0.5 );
$ftp_username_label->set_alignment( 0, 0.5 );
$ftp_password_label->set_alignment( 0, 0.5 );

my $sg_acc = Gtk2::SizeGroup->new('horizontal');
$sg_acc->add_widget($ftp_entry_label);
$sg_acc->add_widget($ftp_mode_label);
$sg_acc->add_widget($ftp_username_label);
$sg_acc->add_widget($ftp_password_label);

$vbox_accounts->pack_start( $accounts_frame, FALSE, TRUE, 3 );
$vbox_accounts->pack_start( $ftp_frame,      FALSE, TRUE, 3 );
$vbox_accounts->set_border_width(5);

#append pages to notebook
my $notebook_settings_first  = $notebook_settings->append_page( $vbox_basic,    $label_basic );
my $notebook_settings_second = $notebook_settings->append_page( $vbox_extras,   $label_extras );
my $notebook_settings_third  = $notebook_settings->append_page( $vbox_behavior, $label_behavior );
my $notebook_settings_fourth = $notebook_settings->append_page( $vbox_accounts, $label_accounts );

#plugins
if ( keys(%plugins) > 0 ) {
	my $scrolled_plugins_window = Gtk2::ScrolledWindow->new;
	$scrolled_plugins_window->set_policy( 'automatic', 'automatic' );
	$scrolled_plugins_window->set_shadow_type('in');
	$scrolled_plugins_window->add($effects_tree);
	my $label_plugins = Gtk2::Label->new;
	$label_plugins->set_markup( $gscrot_common->get_gettext->get("Plugins") );
	my $label_treeview = Gtk2::Label->new( $gscrot_common->get_gettext->get("The following plugins are installed") );
	$label_treeview->set_alignment( 0, 0.5 );
	$effects_vbox->pack_start( $label_treeview,          FALSE, TRUE, 1 );
	$effects_vbox->pack_start( $scrolled_plugins_window, TRUE,  TRUE, 1 );
	$vbox_plugins->pack_start( $effects_vbox,            TRUE,  TRUE, 1 );
	$vbox_plugins->set_border_width(5);
	my $notebook_settings_fifth = $notebook_settings->append_page( $vbox_plugins, $label_plugins );
}

#profiles
$profiles_box->pack_start( $profiles_label,             FALSE, TRUE, 1 );
$profiles_box->pack_start( $combobox_settings_profiles, TRUE,  TRUE, 6 );
$profiles_box->pack_start( $button_profile_save,        FALSE, TRUE, 1 );
$profiles_box->pack_start( $button_profile_delete,      FALSE, TRUE, 1 );
$profiles_box->pack_start( $button_profile_apply,       FALSE, TRUE, 1 );

$vbox_settings->pack_start( $profiles_box,      FALSE, TRUE, 1 );
$vbox_settings->pack_start( $notebook_settings, TRUE,  TRUE, 1 );

#settings
$hbox_settings->pack_start( $vbox_settings, FALSE, TRUE, 6 );
$settings_dialog->vbox->add($hbox_settings);
$settings_dialog->set_default_response('apply');

#main app
$vbox->pack_start( $notebook,  TRUE,  TRUE,  0 );
$vbox->pack_start( $statusbar, FALSE, FALSE, 0 );

#--------------------------------------

#restore session
#--------------------------------------
&fct_load_session;

#start minimized?
#--------------------------------------
unless ( $gscrot_common->get_min ) {
	$window->show_all;
	$is_in_tray = FALSE;
} else {
	$window->hide;
	$is_in_tray = TRUE;
}

#load saved settings
#--------------------------------------
my $folder_to_save = $settings_xml->{'general'}->{'folder'}
	|| $ENV{'HOME'};
if ( $gscrot_common->get_start_with && $folder_to_save ) {
	if ( $gscrot_common->get_start_with eq "raw" ) {
		&evt_take_screenshot( 'global_keybinding', "raw", $folder_to_save );
	} elsif ( $gscrot_common->get_start_with eq "select" ) {
		&evt_take_screenshot( 'global_keybinding', "select", $folder_to_save );
	} elsif ( $gscrot_common->get_start_with eq "window" ) {
		&evt_take_screenshot( 'global_keybinding', "window", $folder_to_save );
	} elsif ( $gscrot_common->get_start_with eq "section" ) {
		&evt_take_screenshot( 'global_keybinding', "section", $folder_to_save );
	}
}

Gtk2->main;

0;

#events
#--------------------------------------
sub evt_navigate {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n"
		if $gscrot_common->get_debug;
	if ( $data eq "first" ) {
		$notebook->set_current_page(0);
	} elsif ( $data eq "last" ) {
		$notebook->set_current_page( $notebook->get_n_pages - 1 );
	} elsif ( $data eq "previous" ) {
		$notebook->prev_page;
	} elsif ( $data eq "forward" ) {
		$notebook->next_page;
	}
	return 1;
}

sub evt_value_changed {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n"
		if $gscrot_common->get_debug;

	return FALSE unless $data;

	#checkbox for "open with" -> entry active/inactive
	if ( $data eq "progname_toggled" ) {
		if ( $progname_active->get_active ) {
			$progname->set_sensitive(TRUE);
		} else {
			$progname->set_sensitive(FALSE);
		}
	}

	#checkbox for "color depth" -> entry active/inactive
	if ( $data eq "im_colors_toggled" ) {
		if ( $im_colors_active->get_active ) {
			$combobox_im_colors->set_sensitive(TRUE);
		} else {
			$combobox_im_colors->set_sensitive(FALSE);
		}
	}

	#checkbox for "delay" -> HScale active/inactive
	if ( $data eq "delay_toggled" ) {
		if ( $delay_active->get_active ) {
			$delay->set_sensitive(TRUE);
		} else {
			$delay->set_sensitive(FALSE);
		}
	}

	#checkbox for "thumbnail" -> HScale active/inactive
	if ( $data eq "thumbnail_toggled" ) {
		if ( $thumbnail_active->get_active ) {
			$thumbnail->set_sensitive(TRUE);
		} else {
			$thumbnail->set_sensitive(FALSE);
		}
	}

	#filetype changed
	if ( $data eq "type_changed" ) {
		if ( $combobox_type->get_active_text =~ /jpeg/ ) {
			$scale->set_sensitive(TRUE);
			$scale_label->set_sensitive(TRUE);
			$scale->set_range( 1, 100 );
			$scale->set_value(90);
			$scale_label->set_text( $gscrot_common->get_gettext->get("Quality") . ":" );
		} elsif ( $combobox_type->get_active_text =~ /png/ ) {
			$scale->set_sensitive(TRUE);
			$scale_label->set_sensitive(TRUE);
			$scale->set_range( 0, 9 );
			$scale->set_value(9);
			$scale_label->set_text( $gscrot_common->get_gettext->get("Compression") . ":" );
		} else {
			$scale->set_sensitive(FALSE);
			$scale_label->set_sensitive(FALSE);
		}
	}

	return TRUE;
}

sub evt_take_screenshot {
	my ( $widget, $data, $folder_from_config ) = @_;

	#disable signal-handler
	$SIG{USR1}  = 'IGNORE';
	$SIG{USR2}  = 'IGNORE';
	$SIG{RTMIN} = 'IGNORE';
	$SIG{RTMAX} = 'IGNORE';

	my $quality_value             = $scale->get_value();
	my $delay_value               = undef;
	my $thumbnail_value           = $thumbnail->get_value;
	my $progname_value            = undef;
	my $filename_value            = undef;
	my $filetype_value            = undef;
	my $folder                    = undef;
	my $screenshot                = undef;
	my $screenshot_name           = undef;
	my $screenshot_thumbnail      = undef;
	my $screenshot_thumbnail_name = undef;
	my $thumbnail_ending          = "thumb";
	print "\n$data was emitted by widget $widget\n"
		if $gscrot_common->get_debug;
	&fct_set_toolbar_sensitive( FALSE, $data );

	#get xid if any window was selected from the submenu...
	my $selfcapture = FALSE;
	if ( $data =~ /^gscrot_window_direct(.*)/ ) {
		my $xid = $1;
		$selfcapture = TRUE if $xid == $window->window->XID;
	}

	#determine current file type (name - description)
	$combobox_type->get_active_text =~ /(.*) -/;
	$filetype_value = $1;
	unless ($filetype_value) {
		$gscrot_dialog->dlg_error_message( $gscrot_common->get_gettext->get("No valid filetype specified"), $d->get("Failed") );
		&fct_set_toolbar_sensitive( TRUE, $data );
		return FALSE;
	}

	#determine folder to save
	$folder = $saveDir_button->get_filename || $folder_from_config;
	utf8::decode $folder;

	if ( $delay_active->get_active ) {
		$delay_value = $delay->get_value;
	} else {
		$delay_value = 0;
	}

	#prepare filename, parse wild-cards
	$filename_value = $filename->get_text();
	utf8::decode $filename_value;
	$filename_value = strftime $filename_value , localtime;

	my $uri = &fct_get_next_filename( $filename_value, $folder, $filetype_value );

	#save current position of main window
	my ( $old_x, $old_y ) = $window->get_position;

	#hide mainwindow
	if (   $hide_active->get_active
		&& ( $data ne "web" && $data ne "tray_web" )
		&& !$is_in_tray
		&& !$selfcapture )
	{
		$window->iconify;
		$window->hide;
		usleep 100000;
		Gtk2::Gdk->flush;
		$is_in_tray = TRUE;
	}

	#fullscreen screenshot
	if ( $data eq "raw" || $data eq "tray_raw" ) {
		my $wnck_screen = Gnome2::Wnck::Screen->get_default;
		unless ( $filename_value =~ /[a-zA-Z0-9]+/
			&& defined($folder)
			&& defined($filetype_value) )
		{
			$gscrot_dialog->dlg_error_message( $gscrot_common->get_gettext->get("No valid filename specified"), $d->get("Failed") );
			&fct_set_toolbar_sensitive( TRUE, $data );
			return FALSE;
		}

		my $screenshooter = GScrot::Screenshot::Workspace->new(
			$gscrot_common, $combobox_cursor->get_active,
			$delay_value, $wnck_screen->get_active_workspace,
			undef, undef, $current_monitor_active->get_active
		);
		$screenshot = $screenshooter->workspace();

		#window
	} elsif ( $data eq "window"
		|| $data eq "tray_window"
		|| $data eq "section"
		|| $data eq "tray_section" )
	{
		unless ( $filename_value =~ /[a-zA-Z0-9]+/ ) {
			$gscrot_dialog->dlg_error_message( $gscrot_common->get_gettext->get("No valid filename specified"), $d->get("Failed") );
			&fct_set_toolbar_sensitive( TRUE, $data );
			return FALSE;
		}

		my $screenshooter = GScrot::Screenshot::Window->new(
			$gscrot_common, $combobox_cursor->get_active,
			$delay_value, $combobox_border->get_active,
			undef, $data, $window, $is_in_tray
		);
		$screenshot = $screenshooter->window_select();

		#selection
	} elsif ( $data eq "select" || $data eq "tray_select" ) {
		unless ( $filename_value =~ /[a-zA-Z0-9]+/ ) {
			$gscrot_dialog->dlg_error_message( $gscrot_common->get_gettext->get("No valid filename specified"), $d->get("Failed") );
			&fct_set_toolbar_sensitive( TRUE, $data );
			return FALSE;
		}
		if ( $tool_advanced->get_active ) {
			my $screenshooter = GScrot::Screenshot::SelectorAdvanced->new( $gscrot_common, $combobox_cursor->get_active, $delay_value );
			$screenshot = $screenshooter->select_advanced();

		} else {
			my $zoom_size_factor = 1;
			$zoom_size_factor = 2 if ( $zoom_size2->get_active );
			$zoom_size_factor = 3 if ( $zoom_size3->get_active );
			my $screenshooter = GScrot::Screenshot::SelectorSimple->new( $gscrot_common, $combobox_cursor->get_active,
				$delay_value, $zoom_size_factor, $zoom_active->get_active );
			$screenshot = $screenshooter->select_simple();
		}

		#web
	} elsif ( $data eq "web" || $data eq "tray_web" ) {

		$screenshot = &dlg_website( $uri->to_string('toplevel-method'), $filetype_label, $quality_value );
		if ( $screenshot != 5 ) {
			eval { $screenshot->isa('Image::Magick'); };
			if ($@) {
				$gscrot_dialog->dlg_error_message( $gscrot_common->get_gettext->get("Unable to capture website"), $d->get("Failed") );
				&dlg_status_message( 1, $gscrot_common->get_gettext->get("Unable to capture website"), $d->get("Failed") );
				&fct_set_toolbar_sensitive( TRUE, $data );
				return FALSE;
			}
		}
	} elsif ( $data =~ /^gscrot_window_direct(.*)/ ) {
		my $xid = $1;
		print "Selected xid: $xid\n" if $gscrot_common->get_debug;
		unless ( $filename_value =~ /[a-zA-Z0-9]+/ ) {
			$gscrot_dialog->dlg_error_message( $gscrot_common->get_gettext->get("No valid filename specified"), $d->get("Failed") );
			&fct_set_toolbar_sensitive( TRUE, $data );
			return FALSE;
		}
		my $screenshooter
			= GScrot::Screenshot::Window->new( $gscrot_common, $combobox_cursor->get_active, $delay_value, $combobox_border->get_active, $xid );
		$screenshot = $screenshooter->window_by_xid();

	} elsif ( $data =~ /^gscrot_wrksp_direct/ ) {

		#we need to handle different wm, e.g. metacity, compiz here

		my $selected_workspace = undef;
		my $vpx                = undef;
		my $vpy                = undef;

		#compiz
		if ( $data =~ /compiz(\d*)x(\d*)/ ) {
			$vpx = $1;
			$vpy = $2;
			print "Sel. Viewport: $vpx, $vpy\n" if $gscrot_common->get_debug;

			#metacity etc.
		} elsif ( $data =~ /gscrot_wrksp_direct(.*)/ ) {
			$selected_workspace = $1;
			print "Sel. Workspace: $selected_workspace\n"
				if $gscrot_common->get_debug;
		}

		unless ( $filename_value =~ /[a-zA-Z0-9]+/ ) {
			$gscrot_dialog->dlg_error_message( $gscrot_common->get_gettext->get("No valid filename specified"), $d->get("Failed") );
			&fct_set_toolbar_sensitive( TRUE, $data );
			return FALSE;
		}
		my $screenshooter = GScrot::Screenshot::Workspace->new( $gscrot_common, $combobox_cursor->get_active,
			$delay_value, $selected_workspace, $vpx, $vpy, $current_monitor_active->get_active );
		$screenshot = $screenshooter->workspace();

	}

	#screenshot was taken at this stage...
	#start postprocessing here

	#...successfully???
	unless ($screenshot) {
		$gscrot_dialog->dlg_error_message(
			$gscrot_common->get_gettext->get("Screenshot failed!\nMaybe mouse pointer could not be grabbed or the selected area is invalid."),
			$d->get("Failed") );
		print "Screenshot failed!" if $gscrot_common->get_debug;
		&dlg_status_message( 1, $gscrot_common->get_gettext->get("Screenshot failed!") );
		&fct_set_toolbar_sensitive( TRUE, $data );

		#focus window after taking a screenshot
		$window->show_all;
		$window->present;
		$is_in_tray = FALSE;

		return FALSE;
	} else {

		#user aborted screenshot
		if ( $screenshot == 5 ) {
			&dlg_status_message( 1, $gscrot_common->get_gettext->get("Capture aborted by user") );
			&fct_set_toolbar_sensitive( TRUE, $data );

			#focus window after taking a screenshot
			$window->show_all;
			$window->present;

			#move window to saved position
			$window->move( $old_x, $old_y );

			$is_in_tray = FALSE;

			return FALSE;
		}

		#we have to use the path (e.g. /home/username/file1.png)
		#so we can save teh screenshot_properly
		$screenshot_name = $uri->get_path();

		#parse wild cards
		my $swidth  = $screenshot->get_width;
		my $sheight = $screenshot->get_height;

		$screenshot_name =~ s/\$w/$swidth/g;
		$screenshot_name =~ s/\$h/$sheight/g;
		print "Trying to save file to $screenshot_name\n"
			if $gscrot_common->get_debug;

		#FINALLY SAVE IT
		if ( $filetype_value =~ /jpeg/ ) {
			$screenshot->save( $screenshot_name, $filetype_value, quality => $quality_value );
		} elsif ( $filetype_value =~ /png/ ) {
			$screenshot->save( $screenshot_name, $filetype_value, compression => $quality_value );
		} else {
			$screenshot->save( $screenshot_name, $filetype_value );
		}

	}    #end screenshot successfull
	if ( $uri->exists ) {

		#quantize
		if ( $im_colors_active->get_active ) {
			my $im_colors_value = $combobox_im_colors->get_active_text();
			$im_colors_value =~ /.*\(([0-9]*).*\)/;
			&fct_imagemagick_perform( 'reduce_colors', $screenshot_name, $im_colors_value );
		}

		#generate the thumbnail
		if ( $thumbnail_active->get_active ) {

			#calculate size
			my $twidth  = int( $screenshot->get_width *  ( $thumbnail_value / 100 ) );
			my $theight = int( $screenshot->get_height * ( $thumbnail_value / 100 ) );

			#create thumbail
			$screenshot_thumbnail = Gtk2::Gdk::Pixbuf->new_from_file_at_scale( $screenshot_name, $twidth, $theight, TRUE );

			#save path of thumbnail
			my $name = fileparse( $uri->get_path, '\..*' );
			$screenshot_thumbnail_name = $uri->get_dirname . "/$name-$thumbnail_ending.$filetype_value";

			#parse wild cards
			$screenshot_thumbnail_name =~ s/\$w/$twidth/g;
			$screenshot_thumbnail_name =~ s/\$h/$theight/g;
			print "Trying to save file to $screenshot_thumbnail_name\n"
				if $gscrot_common->get_debug;

			#FINALLY SAVE IT
			if ( $filetype_value =~ /jpeg/ ) {
				$screenshot_thumbnail->save( $screenshot_thumbnail_name, $filetype_value, quality => $quality_value );
			} elsif ( $filetype_value =~ /png/ ) {
				$screenshot_thumbnail->save( $screenshot_thumbnail_name, $filetype_value, compression => $quality_value );
			} else {
				$screenshot_thumbnail->save( $screenshot_thumbnail_name, $filetype_value );
			}

			unless ( $gscrot_hfunct->file_exists($screenshot_thumbnail_name) ) {
				$gscrot_dialog->dlg_error_message( $$gscrot_common->get_gettext->get("Could not generate thumbnail"), $d->get("Failed") );
				undef $screenshot_thumbnail;
				&fct_set_toolbar_sensitive( TRUE, $data );
				return 0;
			}
		}

		#		my $screenshot_source_uri = Gnome2::VFS::URI->new(Gnome2::VFS->make_uri_from_input ($screenshot_name));

		#		print "Transfer: ".$screenshot_source_uri->to_string()." to ".$uri->to_string."\n";
		#		my $result = Gnome2::VFS::Xfer->uri ($screenshot_source_uri, $uri, 'default', 'abort', 'replace', sub{ return TRUE;});
		#		print "Transfer result: ".$result."\n";

		#integrate it into the notebook
		my $new_key_screenshot = &fct_integrate_screenshot_in_notebook( $uri, $screenshot );

		#thumbnail as well if present
		my $new_key_screenshot_thumbnail = &fct_integrate_screenshot_in_notebook( Gnome2::VFS::URI->new($screenshot_thumbnail_name), $screenshot )
			if $thumbnail_active->get_active;

		#autocopy to clipboard if configured
		if ( $autocopy_active->get_active() ) {
			$clipboard->set_image($screenshot);
		}

		#open screenshot with configured program
		if ( $progname_active->get_active ) {
			my $model         = $progname->get_model();
			my $progname_iter = $progname->get_active_iter();
			if ($progname_iter) {
				$progname_value = $model->get_value( $progname_iter, 2 );
			}
			&fct_open_with_program($progname_value);
		}
		print "screenshot successfully saved to $screenshot_name!\n"
			if $gscrot_common->get_debug;
		&dlg_status_message( 1, "$session_screens{$new_key_screenshot}->{'short'} " . $gscrot_common->get_gettext->get("saved") );
	} else {
		$gscrot_dialog->dlg_error_message(
			$gscrot_common->get_gettext->get("Screenshot failed!\nMaybe mouse pointer could not be grabbed or the selected area is invalid."),
			$d->get("Failed") );
		print "Screenshot failed!" if $gscrot_common->get_debug;
		&dlg_status_message( 1, $gscrot_common->get_gettext->get("Screenshot failed!") );
	}

	&fct_set_toolbar_sensitive( TRUE, $data );

	#focus window after taking a screenshot
	$window->deiconify;
	$window->show_all;

	#move window to saved position
	$window->move( $old_x, $old_y );

	$window->present;
	$is_in_tray = FALSE;

	#attach signal-handler again
	$SIG{USR1}  = sub { &evt_take_screenshot( 'global_keybinding', 'raw' ) };
	$SIG{USR2}  = sub { &evt_take_screenshot( 'global_keybinding', 'window' ) };
	$SIG{RTMIN} = sub { &evt_take_screenshot( 'global_keybinding', 'select' ) };
	$SIG{RTMAX} = sub { &evt_take_screenshot( 'global_keybinding', 'section' ) };

	return TRUE;
}

sub evt_behavior_handle {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n"
		if $gscrot_common->get_debug;

	#checkbox for "keybinding" -> entry active/inactive
	if ( $data eq "keybinding_toggled" ) {
		if ( $keybinding_active->get_active ) {
			$capture_key->set_sensitive(TRUE);
		} else {
			$capture_key->set_sensitive(FALSE);
		}
	}

	#checkbox for "keybinding_sel" -> entry active/inactive
	if ( $data eq "keybinding_sel_toggled" ) {
		if ( $keybinding_sel_active->get_active ) {
			$capture_sel_key->set_sensitive(TRUE);
			$combobox_keybinding_mode->set_sensitive(TRUE);
		} else {
			$capture_sel_key->set_sensitive(FALSE);
			$combobox_keybinding_mode->set_sensitive(FALSE);
		}
	}

	&fct_save_bindings();

	return TRUE;
}

sub evt_notebook_switch {
	my ( $widget, $pointer, $int ) = @_;
	if ( $gscrot_menu->{_menubar} ) {

		#enable/disable menu entry when we are in the session tab and selection changes
		&fct_update_menu($int);

	}

	#	foreach my $key ( keys %session_screens ) {
	#		eval {
	#
	#			#		$session_screens{$key}->{'handle'}->cancel;
	#			$session_screens{$key}->{'image'}->clear;
	#		};
	#	}

	#	my $calc_num = 0;
	#	my ($wwidth, $wheight) = $window->get_size;
	#	foreach my $key ( keys %session_screens ) {
	#		if($session_screens{$key}->{'tab_label'}->window){
	#			my $alloc = $session_screens{$key}->{'tab_label'}->allocation;
	#			print "$wwidth / $alloc->width \n";
	#			$calc_num = int($wwidth / $alloc->width);
	#			last;
	#		}
	#	}
	#
	#	print $calc_num."\n";

	#	$notebook->reorder_child ($session_start_screen{'first_page'}->{'tab_child'}, $int-1);
	return TRUE;
}

sub evt_delete_window {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n"
		if $gscrot_common->get_debug;

	if ( $data ne "menu_quit" && $close_at_close_active->get_active ) {
		$window->hide;
		$is_in_tray = TRUE;
		return TRUE;
	}

	if ( $save_at_close_active->get_active ) {
		$window->hide;
		&fct_save_settings(undef);
		&fct_save_settings( $combobox_settings_profiles->get_active_text )
			if $combobox_settings_profiles->get_active != -1;
	}

	Gtk2->main_quit;
	return FALSE;
}

sub evt_bug {
	$gscrot_hfunct->gnome_open( undef, "https://bugs.launchpad.net/gscrot", undef );
}

sub evt_question {
	$gscrot_hfunct->gnome_open( undef, "https://answers.launchpad.net/gscrot", undef );
}

sub evt_translate {
	$gscrot_hfunct->gnome_open( undef, "https://translations.launchpad.net/gscrot", undef );
}

sub evt_about {
	my ( $widget, $data ) = @_;
	if ( $gscrot_common->get_debug ) {
		print "\n$data was emitted by widget $widget\n";
	}
	open( GPL_HINT, "$gscrot_root/share/gscrot/resources/license/gplv3_hint" )
		or die "ERROR--> Failed to open copyright-file!";
	my @copyright_hint = <GPL_HINT>;
	close(GPL_HINT);
	open( GPL, "$gscrot_root/share/gscrot/resources/license/gplv3" )
		or die "ERROR--> Failed to open license-file!";
	my @copyright = <GPL>;
	close(GPL);
	open( GPL, "$gscrot_root/share/gscrot/resources/pofiles/credits" )
		or die "ERROR--> Failed to open credits-file!";
	my @translators = <GPL>;
	close(GPL);
	my $all_lines = "";

	foreach my $line (@copyright) {
		utf8::decode $line;
		$all_lines = $all_lines . $line;
	}
	my $all_hints = "";
	foreach my $hint (@copyright_hint) {
		utf8::decode $hint;
		$all_hints = $all_hints . $hint;
	}
	my $all_translators = "";
	foreach my $translator (@translators) {
		utf8::decode $translator;
		$all_translators = $all_translators . $translator;
	}
	my $website = "http://launchpad.net/gscrot";
	my $about   = Gtk2::AboutDialog->new;
	my $logo    = Gtk2::Gdk::Pixbuf->new_from_file_at_size( "$gscrot_root/share/pixmaps/gscrot.svg", 150, 150 );
	$about->set_logo($logo);
	$about->set_name(GSCROT_NAME) unless Gtk2->CHECK_VERSION( 2, 12, 0 );
	$about->set_program_name(GSCROT_NAME) if Gtk2->CHECK_VERSION( 2, 12, 0 );
	$about->set_version(GSCROT_VERSION);
	$about->set_url_hook( sub { $gscrot_hfunct->gnome_open(@_) } );
	$about->set_website_label($website);
	$about->set_website($website);
	$about->set_email_hook( sub { $gscrot_hfunct->gnome_open_mail(@_) } );
	$about->set_authors( "Development:\nMario Kemper <mario.kemper\@googlemail.com>\nRene Hennig <Rene.Hennig\@my-united.net>\n\n"
			. "Patches:\nFranco Zeoli\n\n"
			. "Plugins:\nMartin Rabeneck (cornix) <martinrabeneck\@gmx.net>\nEdwood Ocasio <edwood.ocasio\@gmail.com> \n\n"
			. "ubuntu-pics.de:\nRene Hennig <Rene.Hennig\@my-united.net>" );
	$about->set_artists( "Pascal Grochol <pg0803\@gmail.com>", "Arne Weinberg" );
	$about->set_translator_credits($all_translators);
	$about->set_copyright($all_hints);
	$about->set_license($all_lines);
	$about->set_comments(GSCROT_VERSION_FULL);
	$about->show_all;
	$about->signal_connect( 'response' => sub { $about->destroy } );
}

sub evt_show_systray {
	my ( $widget, $data ) = @_;
	if ( $gscrot_common->get_debug ) {
		print "\n$data was emitted by widget $widget\n";
	}

	#left button (mouse)
	if ( $_[1]->button == 1 ) {
		if ( $window->visible ) {
			$window->hide;
			$is_in_tray = TRUE;
		} else {
			$window->show_all;
			$is_in_tray = FALSE;
		}
	}

	#right button (mouse)
	elsif ( $_[1]->button == 3 ) {

		my $tray_menu = &fct_ret_tray_menu;

		$tray_menu->popup(
			undef,    # parent menu shell
			undef,    # parent menu item
			undef,    # menu pos func
			undef,    # data
			$data->button,
			$data->time
		);
	}
	return TRUE;
}

sub evt_show_systray_statusicon {
	my ( $widget, $button, $time, $icon ) = @_;
	if ( $gscrot_common->get_debug ) {
		print "\n$button, $time was emitted by widget $widget\n";
	}

	my $tray_menu = &fct_ret_tray_menu;

	$tray_menu->popup(
		undef,    # parent menu shell
		undef,    # parent menu item
		sub {
			return Gtk2::StatusIcon::position_menu( $tray_menu, 0, 0, $icon );
		},        # menu pos func
		undef,    # data
		$time ? $button : 0,
		$time
	);
	return TRUE;
}

sub evt_activate_systray_statusicon {
	my ( $widget, $data, $icon ) = @_;
	if ( $gscrot_common->get_debug ) {
		print "\n$data was emitted by widget $widget\n";
	}

	if ( $window->visible ) {
		$window->iconify;
		$window->hide;
		$is_in_tray = TRUE;
	} else {
		$window->deiconify;
		$window->show_all;
		$is_in_tray = FALSE;
	}

	return TRUE;
}

sub evt_plugins {
	my ( $tree, $path, $column ) = @_;

	#nothing to do here right now...
	return TRUE;
}

sub evt_accounts {
	my ( $tree, $path, $column ) = @_;

	#open browser if register url is clicked
	if ( $column->get_title eq $gscrot_common->get_gettext->get("Register") ) {
		my $model         = $tree->get_model();
		my $account_iter  = $model->get_iter($path);
		my $account_value = $model->get_value( $account_iter, 3 );
		$gscrot_hfunct->gnome_open( undef, $account_value, undef );
	}
	return TRUE;
}

sub evt_iconview_sel_changed {
	my ( $iconview, $data ) = @_;

	my @sel_items = $iconview->get_selected_items;

	#enable/disable menu entry when we are in the session tab and selection changes
	&fct_update_menu( scalar @sel_items > 0 );

	return TRUE;
}

sub fct_update_menu {
	my $n_items = shift;
	$gscrot_menu->{_menuitem_reopen}->set_sensitive($n_items);
	$gscrot_menu->{_menuitem_reopen}->set_sensitive($n_items);
	$gscrot_menu->{_menuitem_reopen}->set_submenu(&fct_ret_program_menu);
	$gscrot_menu->{_menuitem_rename}->set_sensitive($n_items);
	$gscrot_menu->{_menuitem_upload}->set_sensitive($n_items);
	$gscrot_menu->{_menuitem_draw}->set_sensitive($n_items);
	$gscrot_menu->{_menuitem_plugin}->set_sensitive($n_items);
	$gscrot_menu->{_menuitem_save_as}->set_sensitive($n_items);
	$gscrot_menu->{_menuitem_pagesetup}->set_sensitive($n_items);
	$gscrot_menu->{_menuitem_print}->set_sensitive($n_items);
	$gscrot_menu->{_menuitem_close}->set_sensitive($n_items);
	$gscrot_menu->{_menuitem_trash}->set_sensitive($n_items);
	$gscrot_menu->{_menuitem_copy}->set_sensitive($n_items);
	return TRUE;
}

sub evt_iconview_item_activated {
	my ( $iconview, $path, $data ) = @_;

	my $iter = $session_start_screen{'first_page'}->{'model'}->get_iter($path);
	my $key = $session_start_screen{'first_page'}->{'model'}->get_value( $iter, 2 );

	$notebook->set_current_page( $notebook->page_num( $session_screens{$key}->{'tab_child'} ) );

	return TRUE;
}

sub evt_show_settings {
	&fct_check_installed_programs;

	$settings_dialog->show_all;
	my $settings_dialog_response = $settings_dialog->run;
	if ( $settings_dialog_response eq "close" ) {

		&fct_post_settings($settings_dialog);

		return TRUE;
	} else {

		&fct_post_settings($settings_dialog);

		return FALSE;
	}
}

sub fct_post_settings {
	my $settings_dialog = shift;

	#unset profile combobox when profile was not applied
	if ( $current_profile_indx != $combobox_settings_profiles->get_active ) {
		$combobox_settings_profiles->set_active($current_profile_indx);
	}

	$settings_dialog->hide();

	return TRUE;
}

sub evt_open {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n"
		if $gscrot_common->get_debug;

	my $fs = Gtk2::FileChooserDialog->new(
		$gscrot_common->get_gettext->get("Choose file to open"), $window,
		'open',
		'gtk-cancel' => 'reject',
		'gtk-open'   => 'accept'
	);
	$fs->set_select_multiple(TRUE);

	my $filter_all = Gtk2::FileFilter->new;
	$filter_all->set_name( $gscrot_common->get_gettext->get("All compatible image formats") );
	$fs->add_filter($filter_all);

	foreach ( Gtk2::Gdk::Pixbuf->get_formats ) {
		my $filter = Gtk2::FileFilter->new;
		$filter->set_name( $_->{name} . " - " . $_->{description} );
		foreach ( @{ $_->{extensions} } ) {
			$filter->add_pattern( "*." . uc $_ );
			$filter_all->add_pattern( "*." . uc $_ );
			$filter->add_pattern( "*." . $_ );
			$filter_all->add_pattern( "*." . $_ );
		}
		$fs->add_filter($filter);
	}

	my $key = &fct_get_current_file(undef);
	if ($key) {
		$fs->set_filename( $session_screens{$key}->{'folder'} );
	} elsif ( $ENV{'HOME'} ) {
		$fs->set_filename( $saveDir_button->get_filename() );
	}
	my $fs_resp = $fs->run;

	my @new_files;
	if ( $fs_resp eq "accept" ) {
		@new_files = $fs->get_filenames;
		$fs->destroy();
	} else {
		$fs->destroy();
	}

	#call function to open files - with progress bar etc.
	&fct_open_files(@new_files);

	return TRUE;
}

sub evt_page_setup {
	my ( $widget, $data ) = @_;

	#restore settings if prossible
	my $ssettings = Gtk2::PrintSettings->new;
	if ( $gscrot_hfunct->file_exists("$ENV{ HOME }/.gscrot/printing.xml") ) {
		eval { $ssettings = Gtk2::PrintSettings->new_from_file("$ENV{ HOME }/.gscrot/printing.xml"); };
	}

	$pagesetup = Gtk2::Print->run_page_setup_dialog( $window, $pagesetup, $ssettings );

	return TRUE;
}

sub evt_save_as {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n"
		if $gscrot_common->get_debug;

	my $fs = Gtk2::FileChooserDialog->new(
		$d->get("Choose a location to save to"),
		$window, 'save',
		'gtk-cancel' => 'reject',
		'gtk-save'   => 'accept'
	);

	#determine current tab >> filename
	my $key = &fct_get_current_file(undef);

	$fs->set_current_folder( $session_screens{$key}->{'folder'} );
	$fs->set_current_name( $session_screens{$key}->{'short'} );

	my $extra_hbox = Gtk2::HBox->new;

	my $label_save_as_type = Gtk2::Label->new( $d->get("Image format") . ":" );

	my $combobox_save_as_type = Gtk2::ComboBox->new_text;

	$combobox_save_as_type->insert_text( 0, "JPEG Image - jpeg" );
	$combobox_save_as_type->insert_text( 1, "PNG Image - png" );

	if ( $session_screens{$key}->{'filetype'} eq "jpeg" ) {
		$combobox_save_as_type->set_active(0);
	} elsif ( $session_screens{$key}->{'filetype'} eq "png" ) {
		$combobox_save_as_type->set_active(1);
	} else {
		$combobox_save_as_type->set_active(1);
	}

	$combobox_save_as_type->signal_connect(
		'changed' => sub {
			my $filename = $fs->get_filename;

			my $choosen_format = $combobox_save_as_type->get_active_text;
			$choosen_format =~ s/.*\- //;    #get png or jpeg

			unless ( $filename =~ /.*\.$choosen_format$/ ) {
				$filename =~ s/\..*$/\.$choosen_format/;
			}

			#parse filename
			my ( $short, $folder, $ext ) = fileparse( $filename, '\..*' );

			$fs->set_current_name( $short . $ext );
		}
	);

	$extra_hbox->pack_start( $label_save_as_type,    FALSE, FALSE, 5 );
	$extra_hbox->pack_start( $combobox_save_as_type, FALSE, FALSE, 5 );

	my $align_save_as_type = Gtk2::Alignment->new( 1, 0, 0, 0 );

	$align_save_as_type->add($extra_hbox);
	$align_save_as_type->show_all;

	$fs->set_extra_widget($align_save_as_type);

	my $fs_resp = $fs->run;

	if ( $fs_resp eq "accept" ) {
		my $filename = $fs->get_filename;

		#handle file format
		my $choosen_format = $combobox_save_as_type->get_active_text;
		$choosen_format =~ s/.*\- //;    #get png or jpeg

		unless ( $filename =~ /.*\.$choosen_format$/ ) {
			$filename .= "." . $choosen_format;
		}

		unless ( $gscrot_hfunct->file_exists($filename) ) {
			&fct_imagemagick_perform( "save", $session_screens{$key}->{'long'}, $filename );
		} else {

			if ( $gscrot_dialog->dlg_question_message( $filename . "\n\n" . $d->get("File already exists.\nDo you want to overwrite it?") ) ) {
				&fct_imagemagick_perform( "save", $session_screens{$key}->{'long'}, $filename );
				&fct_create_thumbnail_and_fileinfos( $key, undef, Gnome2::VFS::URI->new( $session_screens{$key}->{'long'} ) );

				&dlg_status_message( 1, "$session_screens{ $key }->{ 'short' } " . $d->get("saved") );

				$fs->destroy();
				return TRUE;
			}
			$fs->destroy();
			return FALSE;
		}

		&fct_update_tab( $key, undef, Gnome2::VFS::URI->new($filename) );

		#setup a new filemonitor, so we get noticed if the file changed
		&fct_add_file_monitor($key);

		&dlg_status_message( 1, "$session_screens{ $key }->{ 'short' } " . $d->get("saved") );

		$fs->destroy();
		return TRUE;
	} else {
		$fs->destroy();
		return FALSE;
	}
}

sub evt_save_profile {
	my ( $widget, $combobox_settings_profiles, $current_profiles_ref ) = @_;
	my $curr_profile_name = $combobox_settings_profiles->get_active_text
		|| "";
	my $new_profile_name = &dlg_profile_name( $curr_profile_name, $combobox_settings_profiles );

	if ($new_profile_name) {
		if ( $curr_profile_name ne $new_profile_name ) {
			$combobox_settings_profiles->prepend_text($new_profile_name);
			$combobox_settings_profiles->set_active(0);
			$current_profile_indx = 0;

			#unshift to array as well
			unshift( @{$current_profiles_ref}, $new_profile_name );

			#populate quick selector as well
			$gscrot_menu->{_menuitem_quicks}->set_submenu( fct_ret_profile_menu( $combobox_settings_profiles, $current_profiles_ref ) );
		}
		&fct_save_settings($new_profile_name);
	}
	return TRUE;
}

sub evt_delete_profile {
	my ( $widget, $combobox_settings_profiles, $current_profiles_ref ) = @_;
	if ( $combobox_settings_profiles->get_active_text ) {
		my $active_text  = $combobox_settings_profiles->get_active_text;
		my $active_index = $combobox_settings_profiles->get_active;
		unlink( "$ENV{'HOME'}/.gscrot/profiles/" . $active_text . ".xml" );
		unlink( "$ENV{'HOME'}/.gscrot/profiles/" . $active_text . "_accounts.xml" );

		unless ( $gscrot_hfunct->file_exists( "$ENV{'HOME'}/.gscrot/profiles/" . $active_text . ".xml" )
			|| $gscrot_hfunct->file_exists( "$ENV{'HOME'}/.gscrot/profiles/" . $active_text . "_accounts.xml" ) )
		{
			$combobox_settings_profiles->remove_text($active_index);
			$combobox_settings_profiles->set_active( $combobox_settings_profiles->get_active + 1 );
			$current_profile_indx = $combobox_settings_profiles->get_active;

			#remove from array as well
			splice( @{$current_profiles_ref}, $active_index, 1 );

			#populate quick selector as well
			$gscrot_menu->{_menuitem_quicks}->set_submenu( fct_ret_profile_menu( $combobox_settings_profiles, $current_profiles_ref ) );

			&dlg_status_message( 1, $d->get("Profile deleted") );
		} else {
			$gscrot_dialog->dlg_error_message( $d->get("Profile could not be deleted"), $d->get("Failed") );
			&dlg_status_message( 1, $d->get("Profile could not be deleted") );
		}
	}
	return TRUE;
}

sub evt_apply_profile {
	my ( $widget, $combobox_settings_profiles, $current_profiles_ref ) = @_;

	if ( $combobox_settings_profiles->get_active_text ) {
		$settings_xml = &fct_load_settings( undef, 'profile_load', $combobox_settings_profiles->get_active_text );
		$current_profile_indx = $combobox_settings_profiles->get_active;

		#populate quick selector as well
		$gscrot_menu->{_menuitem_quicks}->set_submenu( fct_ret_profile_menu( $combobox_settings_profiles, $current_profiles_ref ) );

	}
	return TRUE;
}

#--------------------------------------

#functions
#--------------------------------------

sub fct_create_session_notebook {

	$notebook->set( homogeneous  => TRUE );
	$notebook->set( 'scrollable' => TRUE );

	$notebook->set_size_request( 430, 320 );
	my $hbox_first_label = Gtk2::HBox->new( FALSE, 0 );
	my $thumb_first_icon = Gtk2::Image->new_from_stock( 'gtk-index', 'menu' );
	my $tab_first_label = Gtk2::Label->new();
	$tab_first_label->set_markup( "<b>" . $d->get("Session") . "</b>" );
	$hbox_first_label->pack_start( $thumb_first_icon, FALSE, TRUE, 1 );
	$hbox_first_label->pack_start( $tab_first_label,  TRUE,  TRUE, 1 );
	$hbox_first_label->show_all;

	my $new_index = $notebook->append_page( fct_create_tab( "", TRUE ), $hbox_first_label );
	$session_start_screen{'first_page'}->{'tab_child'} = $notebook->get_nth_page($new_index);

	$notebook->signal_connect( 'switch-page' => \&evt_notebook_switch );

	return $notebook;
}

sub fct_integrate_screenshot_in_notebook {
	my $uri    = shift;
	my $pixbuf = shift;

	#append a page to notebook using with label == filename
	my ( $second, $minute, $hour ) = localtime();
	my $theTime = "$hour:$minute:$second";
	my $key     = "[" . &fct_get_latest_tab_key . "] - $theTime";

	#setup tab label (thumb, preview etc.)
	my $hbox_tab_label = Gtk2::HBox->new( FALSE, 0 );
	my $close_icon = Gtk2::Image->new_from_icon_name( 'gtk-close', 'menu' );

	$session_screens{$key}->{'tab_icon'} = Gtk2::Image->new_from_pixbuf( $session_screens{$key}->{'thumb'} );

	#setup tab label
	my $tab_close_button = Gtk2::Button->new;
	$tab_close_button->set_relief('none');
	$tab_close_button->set_image($close_icon);
	my $tab_label = Gtk2::Label->new($key);
	$hbox_tab_label->pack_start( $session_screens{$key}->{'tab_icon'}, FALSE, TRUE, 1 );
	$hbox_tab_label->pack_start( $tab_label,                           TRUE,  TRUE, 1 );
	$hbox_tab_label->pack_start( $tab_close_button,                    FALSE, TRUE, 1 );
	$hbox_tab_label->show_all;

	#and append page with label == key
	my $new_index = $notebook->append_page( &fct_create_tab( $key, FALSE ), $hbox_tab_label );
	$session_screens{$key}->{'tab_label'} = $hbox_tab_label;
	$session_screens{$key}->{'tab_child'} = $notebook->get_nth_page($new_index);
	$tab_close_button->signal_connect( clicked => sub { &fct_remove($key); } );

	$notebook->set_current_page($new_index);

	if ( &fct_update_tab( $key, $pixbuf, $uri ) ) {

		#build hash of screenshots during session
		#$session_screens{$key}->{'long'} = $uri->get_path;

		#set image
		$session_screens{$key}->{'image'}->set_from_pixbuf( Gtk2::Gdk::Pixbuf->new_from_file( $session_screens{$key}->{'long'} ) );
		$session_screens{$key}->{'image'}->{'current_width'}  = $session_screens{$key}->{'image'}->get_pixbuf->get_width;
		$session_screens{$key}->{'image'}->{'current_height'} = $session_screens{$key}->{'image'}->get_pixbuf->get_height;
		$session_screens{$key}->{'image'}->{'aspect_ratio'}
			= $session_screens{$key}->{'image'}->{'current_width'} / $session_screens{$key}->{'image'}->{'current_height'};

		#setup a filemonitor, so we get noticed if the file changed
		&fct_add_file_monitor($key);
	}

	&fct_update_first_tab;

	return $key;
}

sub fct_add_file_monitor {
	my $key = shift;

	$session_screens{$key}->{'changed'} = FALSE;
	$session_screens{$key}->{'deleted'} = FALSE;
	$session_screens{$key}->{'created'} = FALSE;

	my $result;
	( $result, $session_screens{$key}->{'handle'} ) = Gnome2::VFS::Monitor->add(
		$session_screens{$key}->{'uri'}->to_string,
		'file',
		sub {
			my $handle = shift;
			my $file1  = shift;
			my $file2  = shift;
			my $event  = shift;
			my $key    = shift;

			print $event. " - $key\n";

			if ( $event eq 'deleted' ) {
				$handle->cancel;
				$session_screens{$key}->{'deleted'} = TRUE;
				$session_screens{$key}->{'changed'} = TRUE;
				&fct_update_tab($key);
				&fct_update_first_tab;

			} elsif ( $event eq 'changed' ) {

				#some files receive an CREATED event followed by CHANGED event
				#we don't do anything in this case to avoid unneeded work
				unless ( $session_screens{$key}->{'created'} ) {
					$session_screens{$key}->{'changed'} = TRUE;
					&fct_update_tab($key);
					&fct_update_first_tab;
					print $session_screens{$key}->{'uri'}->to_string . " - " . $event . "\n";
				} else {
					$session_screens{$key}->{'created'} = FALSE;
				}

				#mark file when CREATED - see above
			} elsif ( $event eq 'created' ) {
				$session_screens{$key}->{'created'} = TRUE;
			}

			return TRUE;
		},
		$key
	);

	#TODO - hier nochmal ran...
	print "Added File Monitor: " . Gnome2::VFS->result_to_string($result) . "\n";

	return TRUE;
}

sub fct_set_toolbar_sensitive {
	my ( $set, $data ) = @_;

	#set all buttons insensitive/sensitive
	$gscrot_tool->{_select}->set_sensitive($set);
	$gscrot_tool->{_full}->set_sensitive($set);
	$gscrot_tool->{_window}->set_sensitive($set);
	$gscrot_tool->{_section}->set_sensitive($set);
	$gscrot_tool->{_web}->set_sensitive($set) if ($gnome_web_photo);

	if (   $hide_active->get_active
		&& ( $data ne "web" && $data ne "tray_web" )
		&& !$is_in_tray )
	{
		$window->show_all;
		Gtk2::Gdk->flush;
		$is_in_tray = FALSE;
	}

	return 1;
}

sub fct_create_tab {
	my ( $key, $is_all ) = @_;

	my $vbox            = Gtk2::VBox->new( FALSE, 0 );
	my $vbox_tab        = Gtk2::VBox->new( FALSE, 0 );
	my $hbox_tab        = Gtk2::HBox->new( FALSE, 0 );
	my $vbox_all        = Gtk2::VBox->new( FALSE, 0 );
	my $hbox_all        = Gtk2::HBox->new( FALSE, 0 );
	my $vbox_all2       = Gtk2::VBox->new( FALSE, 0 );
	my $vbox_fileinfos  = Gtk2::VBox->new( FALSE, 0 );
	my $vbox_fileinfos2 = Gtk2::VBox->new( FALSE, 0 );
	my $hbox_tab_file   = Gtk2::HBox->new( FALSE, 0 );

	#keep number (1 = single tab, 2 = session tab) for translation
	my $number = 1;
	$number = 2 if $is_all;

	unless ($is_all) {
		my $filename_label = Gtk2::Label->new;
		$filename_label->set_markup( "<b>" . $d->get("Filename") . "</b>" );
		$session_screens{$key}->{'filename_label'} = Gtk2::Label->new();
		$session_screens{$key}->{'filename_label'}->set_line_wrap(TRUE);
		$session_screens{$key}->{'filename_label'}->set_single_line_mode(FALSE);

		my $folder_label = Gtk2::Label->new;
		$folder_label->set_markup( "<b>" . $d->get("Directory") . "</b>" );
		$session_screens{$key}->{'folder_label'} = Gtk2::Label->new();
		$session_screens{$key}->{'folder_label'}->set_line_wrap(TRUE);
		$session_screens{$key}->{'folder_label'}->set_single_line_mode(FALSE);

		my $mime_type_label = Gtk2::Label->new;
		$mime_type_label->set_markup( "<b>" . $d->get("Mime-Type") . "</b>" );
		$session_screens{$key}->{'mime_type_label'} = Gtk2::Label->new();

		my $size_label = Gtk2::Label->new;
		$size_label->set_markup( "<b>" . $d->get("Filesize") . "</b>" );
		$session_screens{$key}->{'size_label'} = Gtk2::Label->new();

		my $geometry_label = Gtk2::Label->new;
		$geometry_label->set_markup( "<b>" . $d->get("Geometry") . "</b>" );
		$session_screens{$key}->{'geometry_label'} = Gtk2::Label->new();

		#		$session_screens{$key}->{'image'} = Gtk2::Image->new_from_pixbuf( $session_screens{$key}->{'orig'} );
		#
		#		$session_screens{$key}->{'image'}->{'current_width'}  = $session_screens{$key}->{'image'}->get_pixbuf->get_width;
		#		$session_screens{$key}->{'image'}->{'current_height'} = $session_screens{$key}->{'image'}->get_pixbuf->get_height;
		#		$session_screens{$key}->{'image'}->{'aspect_ratio'}
		#			= $session_screens{$key}->{'image'}->{'current_width'} / $session_screens{$key}->{'image'}->{'current_height'};
		#		$session_screens{$key}->{'image_handler'} = $session_screens{$key}->{'image'}->signal_connect( 'expose-event', \&fct_resize_thumb, $key );

		$session_screens{$key}->{'image'} = Gtk2::Image->new();
		$session_screens{$key}->{'image_handler'} = $session_screens{$key}->{'image'}->signal_connect( 'expose-event', \&fct_resize_thumb, $key );

		#packing
		my $tab_infos_sizegroup = Gtk2::SizeGroup->new('vertical');
		$tab_infos_sizegroup->add_widget( $session_screens{$key}->{'filename_label'} );
		$tab_infos_sizegroup->add_widget( $session_screens{$key}->{'folder_label'} );
		$tab_infos_sizegroup->add_widget( $session_screens{$key}->{'size_label'} );
		$tab_infos_sizegroup->add_widget( $session_screens{$key}->{'mime_type_label'} );
		$tab_infos_sizegroup->add_widget( $session_screens{$key}->{'geometry_label'} );

		$vbox_fileinfos->pack_start( $filename_label,                             FALSE, TRUE, 5 );
		$vbox_fileinfos->pack_start( $session_screens{$key}->{'filename_label'},  FALSE, TRUE, 2 );
		$vbox_fileinfos->pack_start( $folder_label,                               FALSE, TRUE, 5 );
		$vbox_fileinfos->pack_start( $session_screens{$key}->{'folder_label'},    FALSE, TRUE, 2 );
		$vbox_fileinfos->pack_start( $size_label,                                 FALSE, TRUE, 10 );
		$vbox_fileinfos->pack_start( $session_screens{$key}->{'size_label'},      FALSE, TRUE, 2 );
		$vbox_fileinfos->pack_start( $mime_type_label,                            FALSE, TRUE, 10 );
		$vbox_fileinfos->pack_start( $session_screens{$key}->{'mime_type_label'}, FALSE, TRUE, 2 );
		$vbox_fileinfos->pack_start( $geometry_label,                             FALSE, TRUE, 10 );
		$vbox_fileinfos->pack_start( $session_screens{$key}->{'geometry_label'},  FALSE, TRUE, 2 );

		$hbox_tab_file->pack_start( $session_screens{$key}->{'image'}, TRUE,  TRUE, 10 );
		$hbox_tab_file->pack_start( $vbox_fileinfos,                   FALSE, TRUE, 1 );
		$hbox_tab_file->pack_start( $vbox_fileinfos2,                  FALSE, TRUE, 1 );

		$vbox_tab->pack_start( $hbox_tab_file, TRUE, TRUE, 0 );

	} else {
		my $stats_label = Gtk2::Label->new;
		$stats_label->set_markup( "<b>" . $d->get("Statistic") . "</b>" );

		$session_start_screen{'first_page'}->{'statistics_counter'} = Gtk2::Label->new(
			$notebook->get_n_pages . " " . $d->nget( "screenshot during this session", "screenshots during this session", $notebook->get_n_pages ) );

		$session_start_screen{'first_page'}->{'size_counter'}
			= Gtk2::Label->new( $d->get("Total size") . ": " . Gnome2::VFS->format_file_size_for_display(0) );

		$vbox_all->pack_start( $stats_label,                                                FALSE, TRUE, 1 );
		$vbox_all->pack_start( $session_start_screen{'first_page'}->{'statistics_counter'}, FALSE, TRUE, 1 );
		$vbox_all->pack_start( $session_start_screen{'first_page'}->{'size_counter'},       FALSE, TRUE, 1 );

		$session_start_screen{'first_page'}->{'settings_label'} = Gtk2::Label->new;
		$session_start_screen{'first_page'}->{'settings_label'}->set_markup( "<b>" . $d->get("Current Preferences") . "</b>" );

		$vbox_all2->pack_start_defaults( $session_start_screen{'first_page'}->{'settings_label'} );

		$session_start_screen{'first_page'}->{'filename_label'} = Gtk2::Label->new( $d->get("Filename") . ": " );
		$session_start_screen{'first_page'}->{'folder_label'}   = Gtk2::Label->new( $d->get("Directory") . ": " );

		my $tab_all_sizegroup = Gtk2::SizeGroup->new('vertical');
		$tab_all_sizegroup->add_widget( $session_start_screen{'first_page'}->{'filename_label'} );
		$tab_all_sizegroup->add_widget( $session_start_screen{'first_page'}->{'folder_label'} );

		$vbox_all2->pack_start_defaults( $session_start_screen{'first_page'}->{'filename_label'} );
		$vbox_all2->pack_start_defaults( $session_start_screen{'first_page'}->{'folder_label'} );

		#create iconview for session
		my $viewmodel = Gtk2::ListStore->new( 'Gtk2::Gdk::Pixbuf', 'Glib::String', 'Glib::String' );
		foreach ( keys %session_screens ) {
			$viewmodel->set( $viewmodel->append, 0, $session_screens{$_}->{'thumb'}, 1, $session_screens{$_}->{'short'}, 2, $_ );
		}
		my $view = Gtk2::IconView->new_with_model($viewmodel);
		$view->set_orientation('horizontal');
		$view->set_pixbuf_column(0);
		$view->set_text_column(1);
		$view->set_selection_mode('multiple');
		$view->set_columns(0);
		$view->signal_connect( 'selection-changed', \&evt_iconview_sel_changed,    'sel_changed' );
		$view->signal_connect( 'item-activated',    \&evt_iconview_item_activated, 'item_activated' );

		$session_start_screen{'first_page'}->{'view'}  = $view;
		$session_start_screen{'first_page'}->{'model'} = $viewmodel;

		$hbox_all->pack_start_defaults($vbox_all);
		$hbox_all->pack_start_defaults($vbox_all2);
		$vbox_tab->pack_start( $hbox_all, FALSE, TRUE, 0 );

		my $scrolled_window_view = Gtk2::ScrolledWindow->new;
		$scrolled_window_view->set_policy( 'automatic', 'automatic' );
		$scrolled_window_view->set_shadow_type('in');
		$scrolled_window_view->add($view);

		$vbox_tab->pack_start( $scrolled_window_view, TRUE, TRUE, 0 );

	}

	$vbox->pack_start_defaults($vbox_tab);
	$vbox->show_all;

	return $vbox;
}

sub fct_resize_thumb {
	my ( $widget, $event, $key ) = @_;

	print "\n$event was emitted by widget $widget and some $key\n" if $gscrot_common->get_debug;

	if ( defined $widget ) {
		my $image = $session_screens{$key}->{'image'};
		my $orig  = $session_screens{$key}->{'orig'};

		my $pixbuf = $image->get_pixbuf;

		my $old_width  = $image->{'current_width'};
		my $old_height = $image->{'current_height'};
		$image->{'current_height'} = $widget->allocation->height - 60;
		$image->{'current_width'}  = $image->{'current_height'} * $image->{'aspect_ratio'};

		my $decr = 10;
		while ($image->{'current_width'} >= $widget->allocation->width - 50
			|| $image->{'current_height'} >= $widget->allocation->height - 50 )
		{
			$image->{'current_height'} -= $decr;
			$image->{'current_width'} = $image->{'current_height'} * $image->{'aspect_ratio'};
		}

		return FALSE if $image->{'current_width'} < 10 || $image->{'current_height'} < 10;

		if (   $old_width != $image->{'current_width'}
			|| $session_screens{$key}->{'changed'} == TRUE
			|| $session_screens{$key}->{'deleted'} == TRUE )
		{

			my $scaled = $orig->scale_simple( $image->{'current_width'}, $image->{'current_height'}, 'tiles' );
			$image->set_from_pixbuf($scaled);
			$session_screens{$key}->{'changed'} = FALSE;

		}
	}
	return FALSE;
}

sub fct_save_settings {
	my ($profilename) = @_;

	#settings file
	my $settingsfile = "$ENV{ HOME }/.gscrot/settings.xml";
	if ( defined $profilename ) {
		$settingsfile = "$ENV{ HOME }/.gscrot/profiles/$profilename.xml"
			if ( $profilename ne "" );
	}

	#session file
	my $sessionfile = "$ENV{ HOME }/.gscrot/session.xml";

	#accounts file
	my $accountsfile = "$ENV{ HOME }/.gscrot/accounts.xml";
	if ( defined $profilename ) {
		$accountsfile = "$ENV{ HOME }/.gscrot/profiles/$profilename\_accounts.xml"
			if ( $profilename ne "" );
	}

	open my $fh_setting, '>', $settingsfile
		or $gscrot_dialog->dlg_error_message( $!, $d->get("Settings could not be saved!") );

	$settings{'general'}->{'last_profile'}      = $combobox_settings_profiles->get_active;
	$settings{'general'}->{'last_profile_name'} = $combobox_settings_profiles->get_active_text
		|| "";

	utf8::encode $settings{'general'}->{'last_profile_name'};

	$settings{'general'}->{'filetype'} = $combobox_type->get_active;
	$settings{'general'}->{'quality'}  = $scale->get_value();
	$settings{'general'}->{'filename'} = $filename->get_text();

	utf8::encode $settings{'general'}->{'filename'};

	$settings{'general'}->{'folder'} = $saveDir_button->get_filename();

	utf8::encode $settings{'general'}->{'folder'};

	#wrksp -> submenu
	$settings{'general'}->{'current_monitor_active'} = $current_monitor_active->get_active;

	$settings{'general'}->{'selection_tool'} = 1
		if $tool_advanced->get_active;
	$settings{'general'}->{'selection_tool'} = 2
		if $tool_simple->get_active;

	$settings{'general'}->{'zoom_active'} = $zoom_active->get_active();
	$settings{'general'}->{'zoom_size'}   = 1
		if ( $zoom_size1->get_active );
	$settings{'general'}->{'zoom_size'} = 2
		if ( $zoom_size2->get_active );
	$settings{'general'}->{'zoom_size'} = 3
		if ( $zoom_size3->get_active );

	#determining timeout
	my $web_menu = $gscrot_tool->{_web}->get_menu;
	my @timeouts = $web_menu->get_children;
	my $timeout  = undef;
	foreach (@timeouts) {

		if ( $_->get_active ) {
			$timeout = $_->get_children->get_text;
			$timeout =~ /([0-9]+)/;
			$timeout = $1;
		}
	}
	$settings{'general'}->{'web_timeout'} = $timeout;

	my $model         = $progname->get_model();
	my $progname_iter = $progname->get_active_iter();

	if ( defined $progname_iter ) {
		my $progname_value = $model->get_value( $progname_iter, 1 );
		$settings{'general'}->{'prog'} = $progname_value;
		utf8::encode $settings{'general'}->{'prog'};
	}

	$settings{'general'}->{'prog_active'}      = $progname_active->get_active();
	$settings{'general'}->{'im_colors'}        = $combobox_im_colors->get_active();
	$settings{'general'}->{'im_colors_active'} = $im_colors_active->get_active();
	$settings{'general'}->{'delay'}            = $delay->get_value();
	$settings{'general'}->{'delay_active'}     = $delay_active->get_active();
	$settings{'general'}->{'thumbnail'}        = $thumbnail->get_value();
	$settings{'general'}->{'thumbnail_active'} = $thumbnail_active->get_active();
	$settings{'general'}->{'border'}           = $combobox_border->get_active();
	$settings{'general'}->{'cursor'}           = $combobox_cursor->get_active();
	$settings{'general'}->{'autohide'}         = $hide_active->get_active();
	$settings{'general'}->{'autocopy'}         = $autocopy_active->get_active();
	$settings{'general'}->{'close_at_close'}   = $close_at_close_active->get_active();
	$settings{'general'}->{'save_at_close'}    = $save_at_close_active->get_active();
	$settings{'general'}->{'keybinding'}       = $keybinding_active->get_active();
	$settings{'general'}->{'keybinding_sel'}   = $keybinding_sel_active->get_active();
	$settings{'general'}->{'keybinding_mode'}  = $combobox_keybinding_mode->get_active();
	$settings{'general'}->{'capture_key'}      = $capture_key->get_text();
	$settings{'general'}->{'capture_sel_key'}  = $capture_sel_key->get_text();

	#ftp upload
	$settings{'general'}->{'ftp_uri'}      = $ftp_remote_entry->get_text();
	$settings{'general'}->{'ftp_mode'}     = $ftp_mode_combo->get_active();
	$settings{'general'}->{'ftp_username'} = $ftp_username_entry->get_text();
	$settings{'general'}->{'ftp_password'} = $ftp_password_entry->get_text();

	#plugins
	foreach my $plugin_key ( sort keys %plugins ) {
		$settings{'plugins'}->{$plugin_key}->{'name'}        = $plugin_key;
		$settings{'plugins'}->{$plugin_key}->{'binary'}      = $plugins{$plugin_key}->{'binary'};
		$settings{'plugins'}->{$plugin_key}->{'name_plugin'} = $plugins{$plugin_key}->{'name'};
		$settings{'plugins'}->{$plugin_key}->{'category'}    = $plugins{$plugin_key}->{'category'};
		$settings{'plugins'}->{$plugin_key}->{'tooltip'}     = $plugins{$plugin_key}->{'tooltip'};
		$settings{'plugins'}->{$plugin_key}->{'ext'}         = $plugins{$plugin_key}->{'ext'};
		$settings{'plugins'}->{$plugin_key}->{'lang'}        = $plugins{$plugin_key}->{'lang'};
		utf8::encode $settings{'plugins'}->{$plugin_key}->{'name'};
		utf8::encode $settings{'plugins'}->{$plugin_key}->{'binary'};
		utf8::encode $settings{'plugins'}->{$plugin_key}->{'name_plugin'};
		utf8::encode $settings{'plugins'}->{$plugin_key}->{'category'};
		utf8::encode $settings{'plugins'}->{$plugin_key}->{'tooltip'};
		utf8::encode $settings{'plugins'}->{$plugin_key}->{'ext'};
		utf8::encode $settings{'plugins'}->{$plugin_key}->{'lang'};
	}

	#settings
	eval {
		XMLout( \%settings, OutputFile => $fh_setting );
		$fh_setting->close();
		&dlg_status_message( 1, $d->get("Settings saved successfully!") );
	};
	if ($@) {
		$gscrot_dialog->dlg_error_message( $@, $d->get("Settings could not be saved!") );
	}

	#session
	open my $fh_session, '>', $sessionfile
		or $gscrot_dialog->dlg_error_message( $!, $d->get("Session could not be saved!") );

	#we need to clean the hashkeys, so they become parseable
	my %clean_files;
	my $counter = 0;
	foreach ( sort keys %session_screens ) {

		next unless exists $session_screens{$_}->{'long'};

		#encode filename
		my $utf8_filename = $session_screens{$_}->{'long'};
		utf8::encode $utf8_filename;

		#8 leading zeros to counter
		$counter = sprintf( "%08d", $counter );
		if ( $gscrot_hfunct->file_exists( $session_screens{$_}->{'long'} ) ) {
			$clean_files{ "file" . $counter }{'filename'} = $utf8_filename;
			$counter++;
		}
	}

	eval {
		XMLout( \%clean_files, OutputFile => $fh_session );
		$fh_session->close();
	};
	if ($@) {
		$gscrot_dialog->dlg_error_message( $@, $d->get("Session could not be saved!") );
	}

	#accounts
	open my $fh_accounts, '>', $accountsfile
		or $gscrot_dialog->dlg_error_message( $!, $d->get("Account-settings could not be saved!") );

	foreach ( keys %accounts ) {
		utf8::encode $accounts{$_}->{'password'};
		utf8::encode $accounts{$_}->{'username'};
		utf8::encode $accounts{$_}->{'register_text'};
		$accounts{$_}->{'password'} = ""
			if $accounts{$_}->{'host'} =~ /imageshack/i;
	}

	eval {
		XMLout( \%accounts, OutputFile => $fh_accounts );
		$fh_accounts->close();
	};
	if ($@) {
		$gscrot_dialog->dlg_error_message( $@, $d->get("Account-settings could not be saved!") );
	}

	return TRUE;
}

sub fct_save_bindings {

	my $client        = Gnome2::GConf::Client->get_default;
	my $shortcut_full = "/apps/metacity/global_keybindings/run_command_screenshot";
	my $shortcut_sel  = "/apps/metacity/global_keybindings/run_command_window_screenshot";
	my $command_full  = "/apps/metacity/keybinding_commands/command_screenshot";
	my $command_sel   = "/apps/metacity/keybinding_commands/command_window_screenshot";

	#set gconf values
	if ( $keybinding_active->get_active() ) {
		$client->set( $command_full, { type => 'string', value => "$gscrot_path --full", } );
		$client->set(
			$shortcut_full,
			{   type  => 'string',
				value => $capture_key->get_text(),
			}
		);
	} else {
		$client->set( $command_full,  { type => 'string', value => 'gnome-screenshot', } );
		$client->set( $shortcut_full, { type => 'string', value => 'Print', } );
	}
	if ( $keybinding_sel_active->get_active() ) {
		my $mode = undef;
		if ( $combobox_keybinding_mode->get_active() == 0 ) {
			$mode = "--selection";
		} elsif ( $combobox_keybinding_mode->get_active() == 1 ) {
			$mode = "--window";
		} elsif ( $combobox_keybinding_mode->get_active() == 2 ) {
			$mode = "--section";
		} else {
			$mode = "--window";
		}
		$client->set(
			$command_sel,
			{   type  => 'string',
				value => "$gscrot_path $mode",
			}
		);
		$client->set(
			$shortcut_sel,
			{   type  => 'string',
				value => $capture_sel_key->get_text(),
			}
		);
	} else {
		$client->set(
			$command_sel,
			{   type  => 'string',
				value => 'gnome-screenshot --window',
			}
		);
		$client->set( $shortcut_sel, { type => 'string', value => '<Alt>Print', } );
	}

	return TRUE;
}

sub fct_load_settings {
	my ( $widget, $data, $profilename ) = @_;

	#settings file
	my $settingsfile = "$ENV{ HOME }/.gscrot/settings.xml";
	$settingsfile = "$ENV{ HOME }/.gscrot/profiles/$profilename.xml"
		if ( defined $profilename );

	my $settings_xml;
	if ( $gscrot_hfunct->file_exists($settingsfile) ) {
		eval {
			$settings_xml = XMLin( IO::File->new($settingsfile) );

			if ( $data eq 'profile_load' ) {

				#general settings
				$combobox_type->set_active( $settings_xml->{'general'}->{'filetype'} );
				$scale->set_value( $settings_xml->{'general'}->{'quality'} );
				utf8::decode $settings_xml->{'general'}->{'filename'};
				$filename->set_text( $settings_xml->{'general'}->{'filename'} );

				utf8::decode $settings_xml->{'general'}->{'folder'};
				$saveDir_button->set_filename( $settings_xml->{'general'}->{'folder'} );

				#FIXME
				#this is a dirty hack to force the setting to be enabled in session tab
				#at the moment i simply dont know why the filechooser "caches" the old value
				# => weird...
				$settings_xml->{'general'}->{'folder_force'} = TRUE;

				#wrksp -> submenu
				$current_monitor_active->set_active( $settings_xml->{'general'}->{'current_monitor_active'} );

				#selection tool -> submenu
				$tool_advanced->set_active(TRUE)
					if $settings_xml->{'general'}->{'selection_tool'} == 1;
				$tool_simple->set_active(TRUE)
					if $settings_xml->{'general'}->{'selection_tool'} == 2;
				$zoom_active->set_active( $settings_xml->{'general'}->{'zoom_active'} );
				$zoom_size1->set_active(TRUE)
					if $settings_xml->{'general'}->{'zoom_size'} == 1;
				$zoom_size2->set_active(TRUE)
					if $settings_xml->{'general'}->{'zoom_size'} == 2;
				$zoom_size3->set_active(TRUE)
					if $settings_xml->{'general'}->{'zoom_size'} == 3;

				#determining timeout
				my $web_menu = $gscrot_tool->{_web}->get_menu;
				my @timeouts = $web_menu->get_children;
				my $timeout  = undef;
				foreach (@timeouts) {
					$timeout = $_->get_children->get_text;
					$timeout =~ /([0-9]+)/;
					$timeout = $1;
					if ( $settings_xml->{'general'}->{'web_timeout'} == $timeout ) {
						$_->set_active(TRUE);
					}
				}

				#advanced settings
				my $model = $progname->get_model;
				utf8::decode $settings_xml->{'general'}->{'prog'};
				$model->foreach( \&fct_iter_programs, $settings_xml->{'general'}->{'prog'} );
				$progname_active->set_active( $settings_xml->{'general'}->{'prog_active'} );
				$im_colors_active->set_active( $settings_xml->{'general'}->{'im_colors_active'} );
				$combobox_im_colors->set_active( $settings_xml->{'general'}->{'im_colors'} );
				$delay->set_value( $settings_xml->{'general'}->{'delay'} );
				$delay_active->set_active( $settings_xml->{'general'}->{'delay_active'} );
				$thumbnail->set_value( $settings_xml->{'general'}->{'thumbnail'} );
				$thumbnail_active->set_active( $settings_xml->{'general'}->{'thumbnail_active'} );
				$combobox_border->set_active( $settings_xml->{'general'}->{'border'} );
				$combobox_cursor->set_active( $settings_xml->{'general'}->{'cursor'} );

				#behavior
				$hide_active->set_active( $settings_xml->{'general'}->{'autohide'} );
				$autocopy_active->set_active( $settings_xml->{'general'}->{'autocopy'} );
				$close_at_close_active->set_active( $settings_xml->{'general'}->{'close_at_close'} );
				$save_at_close_active->set_active( $settings_xml->{'general'}->{'save_at_close'} );

				#keybindings
				$keybinding_active->set_active( $settings_xml->{'general'}->{'keybinding'} );
				$keybinding_sel_active->set_active( $settings_xml->{'general'}->{'keybinding_sel'} );
				$capture_key->set_text( $settings_xml->{'general'}->{'capture_key'} );
				$capture_sel_key->set_text( $settings_xml->{'general'}->{'capture_sel_key'} );
				$combobox_keybinding_mode->set_active( $settings_xml->{'general'}->{'keybinding_mode'} );

				#ftp_upload
				$ftp_remote_entry->set_text( $settings_xml->{'general'}->{'ftp_uri'} );
				$ftp_mode_combo->set_active( $settings_xml->{'general'}->{'ftp_mode'} );
				$ftp_username_entry->set_text( $settings_xml->{'general'}->{'ftp_username'} );
				$ftp_password_entry->set_text( $settings_xml->{'general'}->{'ftp_password'} );
			}

			#load account data
			&fct_load_accounts($profilename);
			if ( defined $accounts_tree ) {
				&fct_load_accounts_tree;
				$accounts_tree->set_model($accounts_model);
				&fct_set_model_accounts($accounts_tree);
			}

			&dlg_status_message( 1, $d->get("Settings loaded successfully") );
			}

	}
	if ($@) {
		$gscrot_dialog->dlg_error_message( $@, $d->get("Settings could not be restored!") );
		unlink $settingsfile;
	}

	#get plugins from cache unless param is set to ignore it
	if ( !$gscrot_common->get_clear_cache ) {

		foreach my $plugin_key ( sort keys %{ $settings_xml->{'plugins'} } ) {
			utf8::decode $settings_xml->{'plugins'}->{$plugin_key}->{'binary'};

			#check if plugin still exists in filesystem
			if ( $gscrot_hfunct->file_exists( $settings_xml->{'plugins'}->{$plugin_key}->{'binary'} ) ) {
				utf8::decode $settings_xml->{'plugins'}->{$plugin_key}->{'name_plugin'};
				utf8::decode $settings_xml->{'plugins'}->{$plugin_key}->{'category'};
				utf8::decode $settings_xml->{'plugins'}->{$plugin_key}->{'tooltip'};
				utf8::decode $settings_xml->{'plugins'}->{$plugin_key}->{'ext'};
				utf8::decode $settings_xml->{'plugins'}->{$plugin_key}->{'lang'};
				$plugins{$plugin_key}->{'binary'}   = $settings_xml->{'plugins'}->{$plugin_key}->{'binary'};
				$plugins{$plugin_key}->{'name'}     = $settings_xml->{'plugins'}->{$plugin_key}->{'name_plugin'};
				$plugins{$plugin_key}->{'category'} = $settings_xml->{'plugins'}->{$plugin_key}->{'category'};
				$plugins{$plugin_key}->{'tooltip'}  = $settings_xml->{'plugins'}->{$plugin_key}->{'tooltip'};
				$plugins{$plugin_key}->{'ext'}      = $settings_xml->{'plugins'}->{$plugin_key}->{'ext'};
				$plugins{$plugin_key}->{'lang'}     = $settings_xml->{'plugins'}->{$plugin_key}->{'lang'};
			} else {
				next;
			}
		}
	}

	#maybe there are new plugins...
	&fct_check_installed_plugins;

	if ( defined $effects_tree ) {
		&fct_load_plugin_tree;
		$effects_tree->set_model($effects_model);
		&fct_set_model_plugins($effects_tree);
	}

	return $settings_xml;
}

sub fct_get_program_model {
	my $model = Gtk2::ListStore->new( 'Gtk2::Gdk::Pixbuf', 'Glib::String', 'Glib::Scalar' );

	my $icontheme = Gtk2::IconTheme->get_for_screen( Gtk2::Gdk::Screen->get_default );

	#FIXME - use png as default mime type (is this clever enough?)
	my ( $default, @apps ) = mime_applications('image/png');

	foreach (@apps) {
		my $program_item = Gtk2::ImageMenuItem->new_with_label();
		my $icon_pixbuf;
		if ( $icontheme->has_icon( $_->Icon ) ) {
			my ( $iw, $ih ) = Gtk2::IconSize->lookup('menu');
			$icon_pixbuf = $icontheme->load_icon( $_->Icon, $ih, 'generic-fallback' );
			$program_item->set_image( Gtk2::Image->new_from_pixbuf($icon_pixbuf) );
		}
		$model->set( $model->append, 0, $icon_pixbuf, 1, $_->Name, 2, $_ );
	}

	return $model;
}

sub fct_load_accounts {
	my ($profilename) = @_;

	#accounts file
	my $accountsfile = "$ENV{ HOME }/.gscrot/accounts.xml";
	$accountsfile = "$ENV{ HOME }/.gscrot/profiles/$profilename\_accounts.xml"
		if ( defined $profilename );

	my $accounts_xml;
	eval { $accounts_xml = XMLin( IO::File->new($accountsfile) ) if $gscrot_hfunct->file_exists($accountsfile); };

	if ($@) {
		$gscrot_dialog->dlg_error_message( $@, $d->get("Account-settings could not be restored!") );
		unlink $accountsfile;
	}

	#account data, load defaults if nothing is set
	unless ( exists( $accounts_xml->{'ubuntu-pics.de'} ) ) {
		$accounts{'ubuntu-pics.de'}->{host}     = "ubuntu-pics.de";
		$accounts{'ubuntu-pics.de'}->{username} = "";
		$accounts{'ubuntu-pics.de'}->{password} = "";
	} else {
		$accounts{'ubuntu-pics.de'}->{host}     = $accounts_xml->{'ubuntu-pics.de'}->{host};
		$accounts{'ubuntu-pics.de'}->{username} = $accounts_xml->{'ubuntu-pics.de'}->{username};
		$accounts{'ubuntu-pics.de'}->{password} = $accounts_xml->{'ubuntu-pics.de'}->{password};
	}

	$accounts{'ubuntu-pics.de'}->{register} = "http://www.ubuntu-pics.de/registrieren.html";

	#account data, load defaults if nothing is set
	unless ( exists( $accounts_xml->{'imageshack.us'} ) ) {
		$accounts{'imageshack.us'}->{host}     = "imageshack.us";
		$accounts{'imageshack.us'}->{username} = "";
		$accounts{'imageshack.us'}->{password} = "";
	} else {
		$accounts{'imageshack.us'}->{host}     = $accounts_xml->{'imageshack.us'}->{host};
		$accounts{'imageshack.us'}->{username} = $accounts_xml->{'imageshack.us'}->{username};
		$accounts{'imageshack.us'}->{password} = $accounts_xml->{'imageshack.us'}->{password};
	}

	$accounts{'imageshack.us'}->{register} = "http://my.imageshack.us/registration/";

	unless ( exists( $accounts_xml->{'imagebanana.com'} ) ) {
		$accounts{'imagebanana.com'}->{host}     = "imagebanana.com";
		$accounts{'imagebanana.com'}->{username} = "";
		$accounts{'imagebanana.com'}->{password} = "";
	} else {
		$accounts{'imagebanana.com'}->{host}     = $accounts_xml->{'imagebanana.com'}->{host};
		$accounts{'imagebanana.com'}->{username} = $accounts_xml->{'imagebanana.com'}->{username};
		$accounts{'imagebanana.com'}->{password} = $accounts_xml->{'imagebanana.com'}->{password};
	}

	$accounts{'imagebanana.com'}->{register} = "http://www.imagebanana.com/myib/registrieren/";

	foreach ( keys %accounts ) {
		utf8::decode $accounts{$_}->{'username'};
		utf8::decode $accounts{$_}->{'password'};
		$accounts{$_}->{'register_color'} = "blue";
		$accounts{$_}->{'register_text'}  = $d->get("click me");
	}

	return TRUE;
}

sub fct_open_files {
	my (@new_files) = @_;

	return FALSE if scalar(@new_files) < 1;

	my $open_dialog = Gtk2::MessageDialog->new( $window, [qw/modal destroy-with-parent/], 'info', 'close', $d->get("Loading files") );

	$open_dialog->set( 'secondary-text' => $d->get("Please wait while your selected files\nare being integrated into GScrot") . "." );

	$open_dialog->signal_connect( response => sub { $_[0]->destroy } );

	my $open_progress = Gtk2::ProgressBar->new;
	$open_progress->set_no_show_all(TRUE);
	$open_progress->set_ellipsize('middle');
	$open_progress->set_orientation('left-to-right');
	$open_progress->set_fraction(0);

	$open_dialog->vbox->add($open_progress);

	#do not show when min at startup
	unless ( $gscrot_common->get_min ) {
		$open_progress->show;
		$open_dialog->show_all;
	}

	my $num_files = scalar(@new_files);
	my $count     = 0;
	foreach (@new_files) {

		#refresh the progressbar
		$count++;
		$open_progress->set_fraction( $count / $num_files );
		$open_progress->set_text($_);

		#refresh tray icon
		if ( $icon && $icon->isa('Gtk2::StatusIcon') ) {
			$icon->set_blinking(TRUE);
		}

		#refresh gui
		&fct_update_gui;

		#do the real work
		&fct_integrate_screenshot_in_notebook($_);
	}
	$open_dialog->response('ok');

	#refresh tray icon
	if ( $icon && $icon->isa('Gtk2::StatusIcon') ) {
		$icon->set_blinking(FALSE);
	}

	return TRUE;
}

sub fct_load_session {

	#session file
	my $sessionfile = "$ENV{ HOME }/.gscrot/session.xml";

	eval {
		my $session_xml = XMLin( IO::File->new($sessionfile) )
			if $gscrot_hfunct->file_exists($sessionfile);

		return FALSE if scalar( keys %{$session_xml} ) < 1;

		my $restore_dialog = Gtk2::MessageDialog->new( $window, [qw/modal destroy-with-parent/], 'info', 'close', undef );

		$restore_dialog->set( 'text' => $d->get("Restoring session") );

		$restore_dialog->set( 'secondary-text' => $d->get("Please wait while your saved session\nis being restored") . "." );

		$restore_dialog->signal_connect( response => sub { $_[0]->destroy } );

		my $restore_progress = Gtk2::ProgressBar->new;
		$restore_progress->set_no_show_all(TRUE);
		$restore_progress->set_ellipsize('middle');
		$restore_progress->set_orientation('left-to-right');
		$restore_progress->set_fraction(0);

		$restore_dialog->vbox->add($restore_progress);

		#do not show when min at startup
		unless ( $gscrot_common->get_min ) {
			$restore_progress->show;
			$restore_dialog->show_all;
			$restore_progress->grab_focus;
		}

		my $num_files = scalar( keys %{$session_xml} );
		my $count     = 0;
		foreach ( sort keys %{$session_xml} ) {

			#refresh the progressbar
			$count++;
			$restore_progress->set_fraction( $count / $num_files );
			$restore_progress->set_text( Gnome2::VFS->format_uri_for_display( ${$session_xml}{$_}{'filename'} ) );

			#refresh tray icon
			if ( $icon && $icon->isa('Gtk2::StatusIcon') ) {
				$icon->set_blinking(TRUE);
			}

			#refresh gui
			&fct_update_gui;

			#do the real work
			&fct_integrate_screenshot_in_notebook( Gnome2::VFS::URI->new( ${$session_xml}{$_}{'filename'} ), undef );
		}
		$restore_dialog->response('ok');

		#refresh tray icon
		if ( $icon && $icon->isa('Gtk2::StatusIcon') ) {
			$icon->set_blinking(FALSE);
		}

	};
	if ($@) {
		$gscrot_dialog->dlg_error_message( $@, $d->get("Session could not be restored!") );

		unlink $sessionfile;

		#refresh tray icon
		if ( $icon && $icon->isa('Gtk2::StatusIcon') ) {
			$icon->set_blinking(FALSE);
		}

	}

	return TRUE;
}

sub fct_screenshot_exists {
	my ($key) = @_;

	#check if file still exists
	unless ( $session_screens{$key}->{'uri'}->exists ) {
		&dlg_status_message( 1, $session_screens{$key}->{'long'} . " " . $d->get("not found") );

		return FALSE;
	}
	return TRUE;
}

sub fct_delete {

	my $key = &fct_get_current_file(undef);

	#single file
	if ($key) {

		if ( $session_screens{$key}->{'uri'}->exists ) {

			#cancel handle
			$session_screens{$key}->{'handle'}->cancel;

			#find trash directory
			my $trash_uri = Gnome2::VFS->find_directory( Gnome2::VFS::URI->new( $ENV{'HOME'} ), 'trash', TRUE, TRUE, 755 );

			#move to trash
			$trash_uri = $trash_uri->append_file_name( $session_screens{$key}->{'short'} );
			$session_screens{$key}->{'uri'}->move( $trash_uri, TRUE ) if $session_screens{$key}->{'uri'}->exists;

		}

		$notebook->remove_page( $notebook->get_current_page );    #delete tab
		&dlg_status_message( 1, $session_screens{$key}->{'long'} . " " . $d->get("deleted") )
			if defined( $session_screens{$key}->{'long'} );

		delete $session_screens{$key};                             # delete from hash

		$window->show_all unless $is_in_tray;

		#session tab
	} else {

		$session_start_screen{'first_page'}->{'view'}->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter = $session_start_screen{'first_page'}->{'model'}->get_iter($path);
				if ( defined $iter ) {
					my $key = $session_start_screen{'first_page'}->{'model'}->get_value( $iter, 2 );
					$notebook->remove_page( $notebook->page_num( $session_screens{$key}->{'tab_child'} ) );

					if ( $session_screens{$key}->{'uri'}->exists ) {

						#cancel handle
						$session_screens{$key}->{'handle'}->cancel;

						#find trash directory
						my $trash_uri = Gnome2::VFS->find_directory( Gnome2::VFS::URI->new( $ENV{'HOME'} ), 'trash', TRUE, TRUE, 755 );

						#move to trash
						$trash_uri = $trash_uri->append_file_name( $session_screens{$key}->{'short'} );
						$session_screens{$key}->{'uri'}->move( $trash_uri, TRUE );

					}

					delete $session_screens{$key};

					&dlg_status_message( 1, $d->get("All screenshots deleted") );

				}
			},
			undef
		);

		$window->show_all unless $is_in_tray;

	}

	&fct_update_first_tab;

	return TRUE;
}

sub fct_remove_all {

	foreach my $key ( keys %session_screens ) {
		if ( exists $session_screens{$key}->{'handle'} ) {

			#cancel handle
			$session_screens{$key}->{'handle'}->cancel;
		}

		$notebook->remove_page( $notebook->page_num( $session_screens{$key}->{'tab_child'} ) );
		delete( $session_screens{$key} );
	}

	&dlg_status_message( 1, $d->get("All screenshots removed") );
	$window->show_all unless $is_in_tray;

	&fct_update_first_tab;

	return TRUE;
}

sub fct_remove {
	my $key = shift;

	$key = &fct_get_current_file(undef) unless $key;

	#single file
	if ($key) {

		if ( exists $session_screens{$key}->{'handle'} ) {

			#cancel handle
			$session_screens{$key}->{'handle'}->cancel;
		}

		$notebook->remove_page( $notebook->page_num( $session_screens{$key}->{'tab_child'} ) );    #delete tab
		&dlg_status_message( 1, $session_screens{$key}->{'long'} . " " . $d->get("removed from session") )
			if defined( $session_screens{$key}->{'long'} );
		delete( $session_screens{$key} );                                                          # delete from hash

		$window->show_all unless $is_in_tray;

	} else {
		$session_start_screen{'first_page'}->{'view'}->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter = $session_start_screen{'first_page'}->{'model'}->get_iter($path);
				if ( defined $iter ) {
					my $key = $session_start_screen{'first_page'}->{'model'}->get_value( $iter, 2 );

					if ( exists $session_screens{$key}->{'handle'} ) {

						#cancel handle
						$session_screens{$key}->{'handle'}->cancel;
					}

					$notebook->remove_page( $notebook->page_num( $session_screens{$key}->{'tab_child'} ) );
					delete( $session_screens{$key} );
				}
			},
			undef
		);

		&dlg_status_message( 1, $d->get("All screenshots removed") );
		$window->show_all unless $is_in_tray;

	}

	&fct_update_first_tab;

	return TRUE;
}

sub fct_update_gui {

	while ( Gtk2->events_pending ) {
		Gtk2->main_iteration;
	}

	return TRUE;
}

sub fct_clipboard {

	my $key = &fct_get_current_file(undef);

	#single file
	if ($key) {

		return FALSE unless &fct_screenshot_exists($key);

		$clipboard->set_image( $session_screens{$key}->{'orig'} );
		&dlg_status_message( 1, $session_screens{$key}->{'long'} . " " . $d->get("copied to clipboard") );

	}
	return TRUE;
}

sub fct_plugin {

	my $key = &fct_get_current_file(undef);

	my @plugin_array;

	#single file
	if ($key) {

		return FALSE unless &fct_screenshot_exists($key);

		unless ( keys %plugins > 0 ) {
			$gscrot_dialog->dlg_error_message( $d->get("No plugin installed"), $d->get("Failed") );
		} else {
			push( @plugin_array, $key );
			&dlg_plugin(@plugin_array);
		}

		#session tab
	} else {

		$session_start_screen{'first_page'}->{'view'}->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter = $session_start_screen{'first_page'}->{'model'}->get_iter($path);
				if ( defined $iter ) {
					my $key = $session_start_screen{'first_page'}->{'model'}->get_value( $iter, 2 );
					push( @plugin_array, $key );
				}

			},
			undef
		);
		&dlg_plugin(@plugin_array);
	}
	return TRUE;
}

sub fct_rename {

	my $key = &fct_get_current_file(undef);

	#single file
	if ($key) {

		return FALSE unless &fct_screenshot_exists($key);

		print "Renaming of file " . $session_screens{$key}->{'long'} . " started\n"
			if $gscrot_common->get_debug;
		&dlg_status_message( 1, $session_screens{$key}->{'long'} . " " . $d->get("renamed") )
			if &dlg_rename($key);

	} else {
		$session_start_screen{'first_page'}->{'view'}->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter = $session_start_screen{'first_page'}->{'model'}->get_iter($path);
				if ( defined $iter ) {
					my $key = $session_start_screen{'first_page'}->{'model'}->get_value( $iter, 2 );
					&dlg_status_message( 1, $session_screens{$key}->{'long'} . " " . $d->get("renamed") )
						if &dlg_rename($key);
				}
			},
			undef
		);
	}

	&fct_update_first_tab;

	return TRUE;
}

sub fct_draw {

	my $key = &fct_get_current_file(undef);

	#single file
	if ($key) {

		return FALSE unless &fct_screenshot_exists($key);

		my $drawing_tool = GScrot::Draw::DrawingTool->new($gscrot_common);
		$drawing_tool->show( $session_screens{$key}->{'long'}, $session_screens{$key}->{'filetype'}, \%session_screens );

	} else {
		$session_start_screen{'first_page'}->{'view'}->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter = $session_start_screen{'first_page'}->{'model'}->get_iter($path);
				if ( defined $iter ) {
					my $key = $session_start_screen{'first_page'}->{'model'}->get_value( $iter, 2 );
					my $drawing_tool = GScrot::Draw::DrawingTool->new($gscrot_common);
					$drawing_tool->show( $session_screens{$key}->{'long'}, $session_screens{$key}->{'filetype'}, \%session_screens );
				}
			},
			undef
		);
	}
	return TRUE;
}

sub fct_upload {

	my $key = &fct_get_current_file(undef);

	my @upload_array;

	#single file
	if ($key) {

		return FALSE unless &fct_screenshot_exists($key);
		push( @upload_array, $session_screens{$key}->{'long'} );
		&dlg_upload(@upload_array);

		#session tab
	} else {

		$session_start_screen{'first_page'}->{'view'}->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter = $session_start_screen{'first_page'}->{'model'}->get_iter($path);
				if ( defined $iter ) {
					my $key = $session_start_screen{'first_page'}->{'model'}->get_value( $iter, 2 );
					return FALSE unless &fct_screenshot_exists($key);
					push( @upload_array, $session_screens{$key}->{'long'} );
				}

			},
			undef
		);
		&dlg_upload(@upload_array);
	}
	return TRUE;
}

sub fct_print {

	my $key = &fct_get_current_file(undef);

	my @pages;
	unless ($key) {
		$session_start_screen{'first_page'}->{'view'}->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter = $session_start_screen{'first_page'}->{'model'}->get_iter($path);
				if ( defined $iter ) {
					my $key = $session_start_screen{'first_page'}->{'model'}->get_value( $iter, 2 );
					push( @pages, $session_screens{$key}->{'long'} );
				}

			}
		);
	} else {
		push( @pages, $session_screens{$key}->{'long'} );
	}

	my $op = Gtk2::PrintOperation->new;
	$op->set_job_name( GSCROT_NAME . " - " . GSCROT_VERSION . " - " . localtime );
	$op->set_n_pages( scalar @pages );
	$op->set_unit('pixel');
	$op->set_show_progress(TRUE);
	$op->set_default_page_setup($pagesetup);

	#restore settings if prossible
	if ( $gscrot_hfunct->file_exists("$ENV{ HOME }/.gscrot/printing.xml") ) {
		eval {
			my $ssettings = Gtk2::PrintSettings->new_from_file("$ENV{ HOME }/.gscrot/printing.xml");
			$op->set_print_settings($ssettings);
		};
	}

	$op->signal_connect(
		'status-changed' => sub {
			my $op = shift;
			&dlg_status_message( 1, $op->get_status_string );
		}
	);

	$op->signal_connect(
		'draw-page' => sub {
			my $op  = shift;
			my $pc  = shift;
			my $int = shift;

			#manip cairo context
			my $cr = $pc->get_cairo_context;

			#see if pixbuf fits on the printing area
			my $pixbuf = Gtk2::Gdk::Pixbuf->new_from_file( $pages[$int] );
			if ( $pc->get_width < $pixbuf->get_width || $pc->get_height < $pixbuf->get_height ) {
				$pixbuf = Gtk2::Gdk::Pixbuf->new_from_file_at_scale( $pages[$int], $pc->get_width, $pc->get_height, TRUE );
			}

			Gtk2::Gdk::Cairo::Context::set_source_pixbuf( $cr, $pixbuf, 0, 0 );

			$cr->paint;
		}
	);

	$op->run( 'print-dialog', $window );

	#save settings
	my $settings = $op->get_print_settings;
	eval { $settings->to_file("$ENV{ HOME }/.gscrot/printing.xml"); };

	return TRUE;
}

sub fct_open_with_program {
	my $dentry = shift;

	my $key = &fct_get_current_file(undef);

	#no program set - take default from settings
	unless ($dentry) {
		my $model         = $progname->get_model();
		my $progname_iter = $progname->get_active_iter();

		if ($progname_iter) {
			$dentry = $model->get_value( $progname_iter, 2 );
		}
	}

	my $exec_call;

	#single file
	if ($key) {

		return FALSE unless &fct_screenshot_exists($key);

		#everything is fine -> open it
		if ( $dentry->wants_uris ) {
			$exec_call = $dentry->parse_Exec( $session_screens{$key}->{'uri'}->to_string );
		} else {
			$exec_call = $dentry->parse_Exec( $session_screens{$key}->{'long'} );
		}

		&dlg_status_message( 1, $session_screens{$key}->{'long'} . " " . $d->get("opened with") . " " . $dentry->Name );

		#session tab
	} else {

		my @open_files;

		$session_start_screen{'first_page'}->{'view'}->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter = $session_start_screen{'first_page'}->{'model'}->get_iter($path);
				if ( defined $iter ) {
					my $key = $session_start_screen{'first_page'}->{'model'}->get_value( $iter, 2 );
					if ( $dentry->wants_uris ) {
						push @open_files, $session_screens{$key}->{'uri'}->to_string;
					} else {
						push @open_files, $session_screens{$key}->{'long'};
					}
				}
			},
			undef
		);
		if ( @open_files > 0 ) {
			if ( $dentry->wants_list ) {
				$exec_call = $dentry->parse_Exec(@open_files);
				&dlg_status_message( 1, $d->get("Opened all files with") . " " . $dentry->Name );
			} else {
				foreach my $file (@open_files) {
					$exec_call .= $dentry->parse_Exec($file) . ";";
				}
			}

		}
	}

	if ($exec_call) {
		foreach ( split /;/, $exec_call ) {
			print Dumper $_ . " &";
			system( $_ . " &" );
		}

	}
	return TRUE;
}

sub fct_execute_plugin {

	my $arrayref = $_[1];
	my ( $plugin_value, $plugin_name, $plugin_lang, $key, $plugin_dialog ) = @$arrayref;

	unless ( $gscrot_hfunct->file_exists( $session_screens{$key}->{'long'} ) ) {
		return FALSE;
	}

	#if it is a native perl plugin, use a plug to integrate it properly
	if ( $plugin_lang eq "perl" ) {
		$plugin_dialog->hide if defined $plugin_dialog;

		#initiate the socket to draw the contents of the plugin to our dialog
		my $plugin_socket = Gtk2::Dialog->new( $plugin_name, $window, [qw/modal destroy-with-parent/] );
		my $socket = Gtk2::Socket->new;
		$plugin_socket->vbox->add($socket);
		$socket->signal_connect(
			'plug-removed' => sub {
				print STDERR "GtkPlug Disconnected\n"
					if $gscrot_common->get_debug;
				$plugin_socket->destroy();
				return TRUE;
				1;
			}
		);
		printf( "\n", $socket->get_id );
		my $pid = fork;
		if ( $pid < 0 ) {
			$gscrot_dialog->dlg_error_message( $d->get("Could not execute plugin") . ": " . $plugin_name, $d->get("Failed") );
		}
		if ( $pid == 0 ) {
			exec(
				sprintf(
					"$^X $plugin_value %d '$session_screens{$key}->{'long'}' $session_screens{$key}->{'width'} $session_screens{$key}->{'height'} $session_screens{$key}->{'filetype'}\n",
					$socket->get_id )
			);
		}
		$plugin_socket->show_all;
		$plugin_socket->run;

		&dlg_status_message( 1, $d->get("Successfully executed plugin") . ": " . $plugin_name );

		#...if not => simple execute the plugin via system (e.g. shell plugins)
	} else {
		print
			"$plugin_value $session_screens{$key}->{'long'} $session_screens{$key}->{'width'} $session_screens{$key}->{'height'} $session_screens{$key}->{'filetype'} submitted to plugin\n"
			if $gscrot_common->get_debug;
		if (system(
				"'$plugin_value' '$session_screens{$key}->{'long'}' '$session_screens{$key}->{'width'}' '$session_screens{$key}->{'height'}' '$session_screens{$key}->{'filetype'}' "
			) == 0
			)
		{
			&dlg_status_message( 1, $d->get("Successfully executed plugin") . ": " . $plugin_name );
		} else {
			$gscrot_dialog->dlg_error_message( $d->get("Could not execute plugin") . ": " . $plugin_name, $d->get("Failed") );
		}
	}

	return TRUE;
}

sub fct_update_first_tab {
	$session_start_screen{'first_page'}->{'view'}->unselect_all;
	$session_start_screen{'first_page'}->{'model'}->clear;

	#create thumbails for iconview
	foreach my $key ( sort keys %session_screens ) {

		#try to generate a new thumbnail
		my $pixbuf;
		eval { $pixbuf = Gtk2::Gdk::Pixbuf->new_from_file_at_scale( $session_screens{$key}->{'long'}, Gtk2::IconSize->lookup('dialog'), TRUE ); };
		if ($@) {
			$pixbuf = Gtk2::Gdk::Pixbuf->new_from_file_at_scale( "$gscrot_root/share/gscrot/resources/icons/Image-missing.svg",
				Gtk2::IconSize->lookup('dialog'), TRUE );
		}

		$session_start_screen{'first_page'}->{'model'}
			->set( $session_start_screen{'first_page'}->{'model'}->append, 0, $pixbuf, 1, $session_screens{$key}->{'short'}, 2, $key );
	}

	$session_start_screen{'first_page'}->{'view'}->set_model( $session_start_screen{'first_page'}->{'model'} );
	$session_start_screen{'first_page'}->{'statistics_counter'}->set_text(
		scalar( keys(%session_screens) ) . " "
			. $d->nget( "screenshot during this session", "screenshots during this session", scalar( keys(%session_screens) ) ) );

	#handle total size in session
	my $total_size = 0;
	foreach ( keys %session_screens ) {
		next unless $session_screens{$_}->{'size'};
		$total_size += $session_screens{$_}->{'size'};
	}
	$session_start_screen{'first_page'}->{'size_counter'}
		->set_text( $d->get("Total size") . ": " . Gnome2::VFS->format_file_size_for_display($total_size) );

	#if size == 0 => no screenshot in session( handle menu entries properly )
	if ( $gscrot_menu->{_menuitem_close_all} ) {

		#enable/disable menu entry when we are in the session tab and selection changes
		&fct_update_menu($total_size);
	}

	#handle session information
	if ( $filename && $saveDir_button && $combobox_settings_profiles ) {

		if ( $combobox_settings_profiles->get_active_text ) {
			$session_start_screen{'first_page'}->{'settings_label'}
				->set_markup( "<b>" . $d->get("Current Preferences") . "</b>" . " (" . $combobox_settings_profiles->get_active_text . ")" );
		} else {
			$session_start_screen{'first_page'}->{'settings_label'}->set_markup( "<b>" . $d->get("Current Preferences") . "</b>" );
		}

		my $current_folder = $saveDir_button->get_filename;

		if ( $settings_xml->{'general'}->{'folder_force'} || !$current_folder ) {
			if ( exists $settings_xml->{'general'}->{'folder'} ) {
				$current_folder = $settings_xml->{'general'}->{'folder'};
			} else {
				$current_folder = $ENV{'HOME'};
			}
			$settings_xml->{'general'}->{'folder_force'} = FALSE;
		}

		if ( $filename->get_text ne "" ) {
			$session_start_screen{'first_page'}->{'filename_label'}->set_text( $d->get("Filename") . ": " . $filename->get_text );
		} else {
			$session_start_screen{'first_page'}->{'filename_label'}->set_text( $d->get("Filename") . ": -" );
		}

		$session_start_screen{'first_page'}->{'folder_label'}->set_text( $d->get("Directory") . ": " . $current_folder );
	}

	return TRUE;
}

sub fct_get_current_file {
	my $index = shift;

	my $curr_page;
	if ($index) {
		$curr_page = $notebook->get_nth_page($index);
	} else {
		$curr_page = $notebook->get_nth_page( $notebook->get_current_page );
	}
	my $key = undef;
	foreach ( keys %session_screens ) {
		next unless ( exists $session_screens{$_}->{'tab_child'} );
		next unless ($curr_page);
		if ( $session_screens{$_}->{'tab_child'} == $curr_page ) {
			$key = $_;
		}
	}
	return $key;
}

sub fct_update_tab {

	#mandatory
	my $key = shift;
	return FALSE unless $key;

	#optional, e.g.used by fct_integrate...
	my $pixbuf = shift;
	my $uri    = shift;

	#update fileinfos
	if ( &fct_create_thumbnail_and_fileinfos( $key, $pixbuf, $uri ) ) {

		eval {

			#update tab icon - maybe pic changed due to use of plugin or drawing tool
			$session_screens{$key}->{'tab_icon'}->set_from_pixbuf( $session_screens{$key}->{'thumb'} );

			$session_screens{$key}->{'filename_label'}->set_text( $session_screens{$key}->{'uri'}->extract_short_name );
			$tooltips->set_tip( $session_screens{$key}->{'filename_label'}, $session_screens{$key}->{'uri'}->to_string );

			$session_screens{$key}->{'folder_label'}->set_text( $session_screens{$key}->{'uri'}->extract_dirname );
			$tooltips->set_tip( $session_screens{$key}->{'folder_label'}, $session_screens{$key}->{'uri'}->extract_dirname );

			$session_screens{$key}->{'mime_type_label'}->set_text( $session_screens{$key}->{'mime_type'} );

			$session_screens{$key}->{'size_label'}->set_text( Gnome2::VFS->format_file_size_for_display( $session_screens{$key}->{'size'} ) );

			$session_screens{$key}->{'geometry_label'}->set_text( $session_screens{$key}->{'width'} . "x" . $session_screens{$key}->{'height'} );
		};
		if ($@) {

			#we handle no case here ;-)
			$gscrot_dialog->dlg_error_message( $@, $d->get("Failed") );

			return FALSE;
		}

		eval {
			if ( $session_screens{$key}->{'image'}->get_pixbuf )
			{
				$session_screens{$key}->{'image'}->{'current_width'}  = $session_screens{$key}->{'image'}->get_pixbuf->get_width;
				$session_screens{$key}->{'image'}->{'current_height'} = $session_screens{$key}->{'image'}->get_pixbuf->get_height;
				$session_screens{$key}->{'image'}->{'aspect_ratio'}
					= $session_screens{$key}->{'image'}->{'current_width'} / $session_screens{$key}->{'image'}->{'current_height'};

				$session_screens{$key}->{'image'}->signal_emit( 'expose-event', Gtk2::Gdk::Event->new('expose') );
			}
		};
		if ($@) {

			#we handle no case here ;-)
			$gscrot_dialog->dlg_error_message( $@, $d->get("Failed") );

			return FALSE;
		}

	} else {

		eval {
			$session_screens{$key}->{'thumb'}
				= Gtk2::Gdk::Pixbuf->new_from_file_at_scale( "$gscrot_root/share/gscrot/resources/icons/Image-missing.svg",
				Gtk2::IconSize->lookup('menu'), TRUE );

			$session_screens{$key}->{'orig'} = Gtk2::Gdk::Pixbuf->new_from_file("$gscrot_root/share/gscrot/resources/icons/Image-missing.svg");

			#do not show an image
			$session_screens{$key}->{'image'}->clear;

			#..and do not watch for changes anymore
			$session_screens{$key}->{'image'}->signal_handler_disconnect( $session_screens{$key}->{'image_handler'} );

			$session_screens{$key}->{'tab_icon'}->set_from_pixbuf( $session_screens{$key}->{'thumb'} );
		};
		if ($@) {

			#we handle no case here ;-)
			$gscrot_dialog->dlg_error_message( $@, $d->get("Failed") );

			return FALSE;
		}

		return FALSE;

	}

	return TRUE;
}

sub fct_get_latest_tab_key {
	my $max_key = 0;
	foreach my $key ( keys %session_screens ) {
		$key =~ /\[(.*)\]/;
		$max_key = $1 if ( $1 > $max_key );
	}
	return $max_key + 1;
}

sub fct_imagemagick_perform {
	my ( $function, $file, $data ) = @_;
	my $image = Image::Magick->new;
	$file = $gscrot_hfunct->switch_home_in_file($file);
	$image->ReadImage($file);

	if ( $function eq "reduce_colors" ) {
		$data =~ /.*\(([0-9]*).*\)/;
		$image->Quantize( colors => 2**$1 );
		$image->WriteImage( filename => $file );
	} elsif ( $function eq "save" ) {
		$image->WriteImage( filename => $data );
	}
	return TRUE;
}

sub fct_check_installed_programs {

	#update list of available programs in settings dialog as well
	if ($progname) {

		my $model         = $progname->get_model();
		my $progname_iter = $progname->get_active_iter();

		#get last prog
		my $progname_value;
		if ( defined $progname_iter ) {
			$progname_value = $model->get_value( $progname_iter, 1 );
			utf8::encode $progname_value;
		}

		#rebuild model with new hash of installed programs...
		$model = &fct_get_program_model;
		$progname->set_model($model);

		#...and try to set last	value
		if ($progname_value) {
			$model->foreach( \&fct_iter_programs, $progname_value );
		} else {
			$progname->set_active(0);
		}

		#nothing has been set
		if ( $progname->get_active == -1 ) {
			$progname->set_active(0);
		}
	}

	return TRUE;
}

sub fct_get_next_filename {

	my ( $filename_value, $folder, $filetype_value ) = @_;

	$filename_value =~ s/\\//g;

	#auto increment
	if ( $filename_value =~ /\%N{1,}/ ) {

		#how many Ns are used? (important for formatting)
		my $pos_proc = index( $filename_value, "%", 0 );
		my $n_counter = 0;
		$pos_proc++;

		while ( $pos_proc <= length($filename_value) ) {
			if ( index( $filename_value, "N", $pos_proc ) != -1 ) {
				$n_counter++;
				$pos_proc++;
			} else {
				last;
			}
		}
		print "$n_counter Ns used in wild-card\n" if $gscrot_common->get_debug;
		my $marks = "";
		my $i     = 0;

		while ( $i < $n_counter ) {
			$marks .= "?";
			$i++;
		}

		$filename_value =~ s/\%N{1,}/$marks/g;
		print "Searching for files with pattern: $filename_value.$filetype_value\n"
			if $gscrot_common->get_debug;

		#get_all files from directory
		#we handle the listing with GnomeVFS to read remote dirs as well
		my @files;
		my ( $result, $uri_list ) = Gnome2::VFS::Directory->open( $folder, 'default' );

		#TODO - hier nochmal ran...
		die Gnome2::VFS->result_to_string($result) unless $result eq 'ok';

		while ( my ( $result, $file ) = $uri_list->read_next ) {
			if ( $result eq 'ok' ) {
				my $fileinfo = Gnome2::VFS::FileInfo->new($file);
				push @files, $fileinfo->{'name'} if $fileinfo->{'name'} =~ /$filename_value/;
			} elsif ( $result eq 'error-eof' ) {
				$uri_list->close();
				last;
			} else {
				next;
			}
		}

		@files = sort { $b cmp $a } @files;

		if ( $gscrot_common->get_debug ) {
			print "All files in directory for this pattern:\n";
			foreach (@files) {
				print $_. " \n";
			}
		}

		#check pos of %NN
		my $pos = index( "$filename_value", "?", 0 );
		my $next_count = 0;
		unless ( $pos == -1 ) {

			foreach (@files) {
				$next_count = substr( $_, $pos, $n_counter );
				next unless $next_count =~ /^(\d+\.?\d*|\.\d+)$/;
				print "Counter at position $pos - $next_count is currently greatest value...\n"
					if $gscrot_common->get_debug;
				last;
			}
		}
		$next_count = 0 unless $next_count =~ /^(\d+\.?\d*|\.\d+)$/;
		$next_count = sprintf( "%0" . $n_counter . "d", $next_count + 1 );
		$marks = quotemeta $marks;
		$filename_value =~ s/$marks/$next_count/g;
	}

	#create new uri
	my $new_uri = Gnome2::VFS::URI->new("$folder/$filename_value.$filetype_value");

	print "Checking new uri: " . $new_uri->to_string . "\n";
	if ( $new_uri->exists ) {
		my $count             = 1;
		my $existing_filename = $filename_value;
		while ( $new_uri->exists ) {
			$filename_value = $existing_filename . "(" . sprintf( "%03d", $count++ ) . ")";
			$new_uri        = $folder;
			$new_uri        = $new_uri->append_string("$filename_value.$filetype_value");
			print "Checking new uri: " . $new_uri->to_string . "\n";
		}
	}

	return $new_uri;
}

sub fct_check_installed_plugins {

	my @plugin_paths = ( "$gscrot_root/share/gscrot/resources/system/plugins/*/*", "$ENV{'HOME'}/.gscrot/plugins/*/*" );

	foreach my $plugin_path (@plugin_paths) {
		my @plugins = glob($plugin_path);
		foreach (@plugins) {
			if ( -d $_ ) {
				my $dir_name = $_;

				#parse filename
				my ( $name, $folder, $type ) = fileparse( $dir_name, '\..*' );

				if ( $gscrot_hfunct->file_exists("$dir_name/$name") ) {

					unless ( $plugins{$_}->{'binary'}
						&& $plugins{$_}->{'name'}
						&& $plugins{$_}->{'category'}
						&& $plugins{$_}->{'tooltip'}
						&& $plugins{$_}->{'ext'}
						&& $plugins{$_}->{'lang'} )
					{

						print "\nINFO: new plugin information detected - $dir_name/$name\n";

						#path to executable
						$plugins{$_}->{'binary'} = "$dir_name/$name";

						#name
						$plugins{$_}->{'name'} = &fct_plugin_get_info( $plugins{$_}->{'binary'}, 'name' );

						#category
						$plugins{$_}->{'category'} = &fct_plugin_get_info( $plugins{$_}->{'binary'}, 'sort' );

						#tooltip
						$plugins{$_}->{'tooltip'} = &fct_plugin_get_info( $plugins{$_}->{'binary'}, 'tip' );

						#extensions
						$plugins{$_}->{'ext'} = &fct_plugin_get_info( $plugins{$_}->{'binary'}, 'ext' );

						#language (shell, perl etc.)
						$plugins{$_}->{'lang'} = &fct_plugin_get_info( $plugins{$_}->{'binary'}, 'lang' );

					}

					$plugins{$_}->{'lang'} = "shell"
						if $plugins{$_}->{'lang'} eq "";

					chomp( $plugins{$_}->{'name'} );
					chomp( $plugins{$_}->{'category'} );
					chomp( $plugins{$_}->{'tooltip'} );
					chomp( $plugins{$_}->{'ext'} );
					chomp( $plugins{$_}->{'lang'} );

					#check if plugin can handle png and/or jpeg
					$plugins{$_}->{'pixbuf_jpeg'} = 'gtk-no';
					$plugins{$_}->{'pixbuf_png'}  = 'gtk-no';
					$plugins{$_}->{'pixbuf_jpeg'} = 'gtk-yes'
						if ( $plugins{$_}->{'ext'} =~ /jpeg/ );
					$plugins{$_}->{'pixbuf_png'} = 'gtk-yes'
						if ( $plugins{$_}->{'ext'} =~ /png/ );

					#pixbuf
					$plugins{$_}->{'pixbuf'} = $plugins{$_}->{'binary'} . ".png"
						if ( $gscrot_hfunct->file_exists( $plugins{$_}->{'binary'} . ".png" ) );
					$plugins{$_}->{'pixbuf'} = $plugins{$_}->{'binary'} . ".svg"
						if ( $gscrot_hfunct->file_exists( $plugins{$_}->{'binary'} . ".svg" ) );

					if ( $gscrot_hfunct->file_exists( $plugins{$_}->{'pixbuf'} ) ) {
						$plugins{$_}->{'pixbuf_object'}
							= Gtk2::Gdk::Pixbuf->new_from_file_at_size( $plugins{$_}->{'pixbuf'}, Gtk2::IconSize->lookup('menu') );
					} else {
						$plugins{$_}->{'pixbuf'} = "$gscrot_root/share/gscrot/resources/icons/executable.svg";
						$plugins{$_}->{'pixbuf_object'}
							= Gtk2::Gdk::Pixbuf->new_from_file_at_size( $plugins{$_}->{'pixbuf'}, Gtk2::IconSize->lookup('menu') );
					}
					if ( $gscrot_common->get_debug ) {
						print "$plugins{$_}->{'name'} - $plugins{$_}->{'binary'}\n";
					}
				} else {
					delete $plugins{$_};
				}    #endif binary exists
			}
		}
	}

	return TRUE;
}

sub fct_plugin_get_info {
	my ( $plugin, $info ) = @_;

	my $plugin_info = `$plugin $info`;
	utf8::decode $plugin_info;

	return $plugin_info;
}

sub fct_create_thumbnail_and_fileinfos {

	#mandatory
	my $key = shift;
	return FALSE unless $key;

	#optional, e.g.used by fct_integrate...
	my $pixbuf = shift;
	my $uri    = shift;

	print "Updating fileinfos for key: $key\n";

	eval {

		$session_screens{$key}->{'uri'}      = $uri if $uri;
		$session_screens{$key}->{'short'}    = $session_screens{$key}->{'uri'}->extract_short_name;
		$session_screens{$key}->{'long'}     = $session_screens{$key}->{'uri'}->get_path;
		$session_screens{$key}->{'folder'}   = $session_screens{$key}->{'uri'}->extract_dirname;
		$session_screens{$key}->{'filetype'} = $session_screens{$key}->{'short'};
		$session_screens{$key}->{'filetype'} =~ s/.*\.//ig;

		#volume infos
		my $volume_monitor = Gnome2::VFS->get_volume_monitor();
		my $volume         = $volume_monitor->get_volume_for_path( $session_screens{$key}->{'folder'} );
		$session_screens{$key}->{'volume_device_type'}     = $volume->get_device_type;
		$session_screens{$key}->{'volume_device_path'}     = $volume->get_device_path;
		$session_screens{$key}->{'volume_filesystem_type'} = $volume->get_filesystem_type;
		$session_screens{$key}->{'volume_volume_type'}     = $volume->get_volume_type;
		$session_screens{$key}->{'volume_activation_uri'}  = $volume->get_activation_uri;
		$session_screens{$key}->{'volume_display_name'}    = $volume->get_display_name;
		$session_screens{$key}->{'volume_handled_trash'}   = $volume->handles_trash;

		#just the name
		$session_screens{$key}->{'name'} = fileparse( $session_screens{$key}->{'long'}, '\..*' );

		$session_screens{$key}->{'fileinfo'}  = $session_screens{$key}->{'uri'}->get_file_info('default');
		$session_screens{$key}->{'size'}      = $session_screens{$key}->{'fileinfo'}->{'size'};
		$session_screens{$key}->{'mime_type'} = Gnome2::VFS->get_mime_type( $session_screens{$key}->{'uri'}->to_string );

		#maybe we have a pixbuf already (e.g. after taking a screenshot)
		unless ($pixbuf) {
			$session_screens{$key}->{'orig'} = Gtk2::Gdk::Pixbuf->new_from_file( $session_screens{$key}->{'long'} );
		} else {
			$session_screens{$key}->{'orig'} = $pixbuf;
		}

		#get dimensions - using the pixbuf
		$session_screens{$key}->{'width'}  = $session_screens{$key}->{'orig'}->get_width;
		$session_screens{$key}->{'height'} = $session_screens{$key}->{'orig'}->get_height;

		#use different algos for image sizes...
		if ( $session_screens{$key}->{'orig'}->get_width + $session_screens{$key}->{'orig'}->get_height > 5000 ) {
			$session_screens{$key}->{'thumb'} = $session_screens{$key}->{'orig'}->scale_simple( Gtk2::IconSize->lookup('menu'), 'nearest' );
		} else {
			$session_screens{$key}->{'thumb'} = $session_screens{$key}->{'orig'}->scale_simple( Gtk2::IconSize->lookup('menu'), 'tiles' );
		}

	};

	if ($@) {

		#we only handle one case here:
		#file was deleted in filesystem and we got informed about that...
		if ( $session_screens{$key}->{'deleted'} == TRUE ) {
			$gscrot_dialog->dlg_error_message(
				$d->get("Maybe it was deleted by another person or process") . ".",
				sprintf( $d->get("Image %s was not found"), "'" . $session_screens{$key}->{'uri'}->to_string . "'" ),
				'gtk-discard', 'gtk-save-as'
			);

			#all other cases are unknown => show "real" error
		} else {
			$gscrot_dialog->dlg_error_message( $@, $d->get("Failed") );
		}

		return FALSE;
	}

	return TRUE;
}

sub fct_iter_programs {
	my ( $model, $path, $iter, $search_for ) = @_;
	my $progname_value = $model->get_value( $iter, 1 );
	return FALSE if $search_for ne $progname_value;
	$progname->set_active_iter($iter);
	return TRUE;
}

sub fct_ret_workspace_menu {
	my $init = shift;

	my $menu_wrksp = Gtk2::Menu->new;

	my $screen = Gnome2::Wnck::Screen->get_default;
	$screen->force_update();

	my $wm_name = Gtk2::Gdk::Screen->get_default->get_window_manager_name;

	my $active_workspace = $screen->get_active_workspace;

	#we need to handle different window managers here because there are some different models related
	#to workspaces and viewports
	#	compiz uses "one workspace" - "multiple viewports" model for example
	#	default gnome wm metacity simply uses multiple workspaces
	#we will try to handle them by name

	#compiz
	if ( $wm_name =~ /compiz/ ) {

		#calculate viewports with size of workspace
		my $vpx = $active_workspace->get_viewport_x;
		my $vpy = $active_workspace->get_viewport_y;

		my $n_viewports_column = int( $active_workspace->get_width / $screen->get_width );
		my $n_viewports_rows   = int( $active_workspace->get_height / $screen->get_height );

		#rows
		for ( my $j = 0; $j < $n_viewports_rows; $j++ ) {

			#columns
			for ( my $i = 0; $i < $n_viewports_column; $i++ ) {
				my @vp = ( $i * $screen->get_width, $j * $screen->get_height );
				my $vp_name = "$wm_name x: $i y: $j";

				print "gscrot_wrksp_direct_compiz" . $vp[0] . "x" . $vp[1] . "\n"
					if $gscrot_common->get_debug;

				my $vp_item = Gtk2::MenuItem->new_with_label( ucfirst $vp_name );
				$vp_item->signal_connect(
					'activate' => \&evt_take_screenshot,
					"gscrot_wrksp_direct_compiz" . $vp[0] . "x" . $vp[1]
				);
				$menu_wrksp->append($vp_item);

				#do not offer current viewport
				if ( $vp[0] == $vpx && $vp[1] == $vpy ) {
					$vp_item->set_sensitive(FALSE);
				}
			}    #columns
		}    #rows

		#all other wm manager like metacity etc.
		#we could add more of them here if needed
	} else {

		my @workspaces = ();
		for ( my $wcount = 0; $wcount < $screen->get_workspace_count; $wcount++ ) {
			push( @workspaces, $screen->get_workspace($wcount) );
		}

		foreach my $space (@workspaces) {
			next unless defined $space;

			my $wrkspace_item = Gtk2::MenuItem->new_with_label( $space->get_name );
			$wrkspace_item->signal_connect(
				'activate' => \&evt_take_screenshot,
				"gscrot_wrksp_direct" . $space->get_number
			);
			$menu_wrksp->append($wrkspace_item);
			if ( $active_workspace->get_number == $space->get_number ) {
				$wrkspace_item->set_sensitive(FALSE);
			}
		}
	}

	my $n_mons = Gtk2::Gdk::Screen->get_default->get_n_monitors;

	#use only current monitore
	$menu_wrksp->append( Gtk2::SeparatorMenuItem->new );
	if ($init) {
		$current_monitor_active = Gtk2::CheckMenuItem->new_with_label( $d->get("Limit to current monitor") );
		if ( defined $settings_xml->{'general'}->{'current_monitor_active'} ) {
			$current_monitor_active->set_active( $settings_xml->{'general'}->{'current_monitor_active'} );
		} else {
			$current_monitor_active->set_active(FALSE);
		}
		$menu_wrksp->append($current_monitor_active);
	} else {
		$current_monitor_active->reparent($menu_wrksp);
	}

	$tooltips->set_tip(
		$current_monitor_active,
		sprintf(
			$d->nget(
				"This option is only useful when you are running a multi-monitor system (%d monitor detected).\nEnable it to capture only the current monitor.",
				"This option is only useful when you are running a multi-monitor system (%d monitors detected).\nEnable it to capture only the current monitor.",
				$n_mons
			),
			$n_mons
		)
	);
	if ( $n_mons > 1 ) {
		$current_monitor_active->set_sensitive(TRUE);
	} else {
		$current_monitor_active->set_active(FALSE);
		$current_monitor_active->set_sensitive(FALSE);
	}

	$gscrot_tool->{_full}->set_menu($menu_wrksp);
	$menu_wrksp->show_all();
	return $menu_wrksp;
}

sub fct_ret_window_menu {
	my $screen = Gnome2::Wnck::Screen->get_default;
	$screen->force_update();

	my $menu_windows = Gtk2::Menu->new;
	foreach my $win ( $screen->get_windows ) {
		if ( $win->is_visible_on_workspace( $screen->get_active_workspace ) ) {
			my $window_item = Gtk2::ImageMenuItem->new_with_label( $win->get_name );
			$window_item->set_image( Gtk2::Image->new_from_pixbuf( $win->get_mini_icon ) );
			$window_item->signal_connect(
				'activate' => \&evt_take_screenshot,
				"gscrot_window_direct" . $win->get_xid
			);
			$menu_windows->append($window_item);
		}
	}
	$gscrot_tool->{_window}->set_menu($menu_windows);
	$menu_windows->show_all;
	return $menu_windows;
}

sub fct_ret_tray_menu {

	my $tray_menu       = Gtk2::Menu->new();
	my $menuitem_select = Gtk2::ImageMenuItem->new( $d->get("Selection") );
	$menuitem_select->set_image(
		Gtk2::Image->new_from_pixbuf(
			Gtk2::Gdk::Pixbuf->new_from_file_at_size( "$gscrot_root/share/gscrot/resources/icons/selection.svg", Gtk2::IconSize->lookup('menu') )
		)
	);
	$menuitem_select->signal_connect(
		activate => \&evt_take_screenshot,
		'tray_select'
	);
	my $menuitem_raw = Gtk2::ImageMenuItem->new( $d->get("Full Screen") );
	$menuitem_raw->set_image(
		Gtk2::Image->new_from_pixbuf(
			Gtk2::Gdk::Pixbuf->new_from_file_at_size( "$gscrot_root/share/gscrot/resources/icons/fullscreen.svg", Gtk2::IconSize->lookup('menu') )
		)
	);
	$menuitem_raw->signal_connect(
		activate => \&evt_take_screenshot,
		'tray_raw'
	);
	my $menuitem_window = Gtk2::ImageMenuItem->new( $d->get("Window") );
	$menuitem_window->set_image(
		Gtk2::Image->new_from_pixbuf(
			Gtk2::Gdk::Pixbuf->new_from_file_at_size( "$gscrot_root/share/gscrot/resources/icons/sel_window.svg", Gtk2::IconSize->lookup('menu') )
		)
	);
	$menuitem_window->signal_connect(
		activate => \&evt_take_screenshot,
		'tray_window'
	);
	my $menuitem_window_sect = Gtk2::ImageMenuItem->new( $d->get("Section") );
	$menuitem_window_sect->set_image(
		Gtk2::Image->new_from_pixbuf(
			Gtk2::Gdk::Pixbuf->new_from_file_at_size(
				"$gscrot_root/share/gscrot/resources/icons/sel_window_section.svg",
				Gtk2::IconSize->lookup('menu')
			)
		)
	);
	$menuitem_window_sect->signal_connect(
		activate => \&evt_take_screenshot,
		'tray_section'
	);
	my $menuitem_web = Gtk2::ImageMenuItem->new( $d->get("Web") );
	$menuitem_web->set_sensitive($gnome_web_photo);
	$menuitem_web->set_image(
		Gtk2::Image->new_from_pixbuf(
			Gtk2::Gdk::Pixbuf->new_from_file_at_size( "$gscrot_root/share/gscrot/resources/icons/web_image.svg", Gtk2::IconSize->lookup('menu') )
		)
	);
	$menuitem_web->signal_connect(
		activate => \&evt_take_screenshot,
		'tray_web'
	);
	my $menuitem_info = Gtk2::ImageMenuItem->new( $d->get("Info") );
	$menuitem_info->set_image( Gtk2::Image->new_from_icon_name( 'gtk-about', 'menu' ) );
	$menuitem_info->signal_connect( "activate", \&evt_about, $window );
	my $menuitem_quit = Gtk2::ImageMenuItem->new( $d->get("Quit") );
	$menuitem_quit->set_image( Gtk2::Image->new_from_icon_name( 'gtk-quit', 'menu' ) );
	$menuitem_quit->signal_connect( "activate", \&evt_delete_window, 'menu_quit' );
	$tray_menu->append($menuitem_select);
	$tray_menu->append( Gtk2::SeparatorMenuItem->new );
	$tray_menu->append($menuitem_raw);
	$tray_menu->append( Gtk2::SeparatorMenuItem->new );
	$tray_menu->append($menuitem_window);
	$tray_menu->append($menuitem_window_sect);
	$tray_menu->append( Gtk2::SeparatorMenuItem->new );
	$tray_menu->append($menuitem_web);
	$tray_menu->append( Gtk2::SeparatorMenuItem->new );
	$tray_menu->append($menuitem_info);
	$tray_menu->append($menuitem_quit);
	$tray_menu->show_all;

	return $tray_menu;
}

sub fct_ret_sel_menu {

	#PREF MENU
	my $menu_settings = Gtk2::Menu->new;
	$zoom_active = Gtk2::CheckMenuItem->new_with_label( $d->get("Enable zoom window") );
	if ( defined $settings_xml->{'general'}->{'zoom_active'} ) {
		$zoom_active->set_active( $settings_xml->{'general'}->{'zoom_active'} );
	} else {
		$zoom_active->set_active(TRUE);
	}

	my $menu_size  = Gtk2::MenuItem->new_with_label( $d->get("Size of zoom window") );
	my $menu_size2 = Gtk2::Menu->new;
	$zoom_size1 = Gtk2::RadioMenuItem->new( undef,       $d->get("Small") );
	$zoom_size2 = Gtk2::RadioMenuItem->new( $zoom_size1, $d->get("Medium") );
	$zoom_size3 = Gtk2::RadioMenuItem->new( $zoom_size1, $d->get("Large") );

	if ( defined $settings_xml->{'general'}->{'zoom_size'} ) {
		$zoom_size1->set_active(TRUE)
			if $settings_xml->{'general'}->{'zoom_size'} == 1;
		$zoom_size2->set_active(TRUE)
			if $settings_xml->{'general'}->{'zoom_size'} == 2;
		$zoom_size3->set_active(TRUE)
			if $settings_xml->{'general'}->{'zoom_size'} == 3;
	} else {
		$zoom_size1->set_active(TRUE);
	}

	#TOP MENU
	my $menu_sel = Gtk2::Menu->new;

	#advanced tool
	$tool_advanced = Gtk2::RadioMenuItem->new( undef, $d->get("Advanced selection tool") );

	#simple tool
	$tool_simple = Gtk2::RadioMenuItem->new( $tool_advanced, $d->get("Simple selection tool") );

	#and some more preferences
	my $advanced_settings = Gtk2::MenuItem->new_with_label( $d->get("Preferences") );

	$menu_sel->append($tool_advanced);
	$menu_sel->append($tool_simple);
	$menu_sel->append($advanced_settings);

	$menu_size->set_submenu($menu_size2);
	$menu_size2->append($zoom_size1);
	$menu_size2->append($zoom_size2);
	$menu_size2->append($zoom_size3);

	$menu_settings->append($zoom_active);
	$menu_settings->append($menu_size);
	$advanced_settings->set_submenu($menu_settings);

	$tool_simple->signal_connect(
		'activate' => sub {
			my $widget = shift;
			if ( $widget->get_active ) {
				$advanced_settings->set_sensitive(TRUE);
			} else {
				$advanced_settings->set_sensitive(FALSE);
			}
		}
	);

	#set saved/default settings
	if ( defined $settings_xml->{'general'}->{'selection_tool'} ) {
		if ( $settings_xml->{'general'}->{'selection_tool'} == 1 ) {
			$tool_advanced->set_active(TRUE);
			$advanced_settings->set_sensitive(FALSE);
		} elsif ( $settings_xml->{'general'}->{'selection_tool'} == 2 ) {
			$tool_simple->set_active(TRUE);
			$advanced_settings->set_sensitive(TRUE);
		}
	} else {
		$tool_advanced->set_active(TRUE);
		$advanced_settings->set_sensitive(FALSE);
	}

	#check if Gtk2::ImageView is supported
	if ($gtkimageview) {
		$tooltips->set_tip( $tool_advanced,
			$d->get("The advanced selection tool allows you to enlarge/shrink or move your selected area\nuntil you finally take the screenshot.") );
	} else {
		$tool_advanced->set_sensitive(FALSE);
		$tooltips->set_tip( $tool_advanced, $d->get("Gtk2::ImageView needs to be installed for this feature") );

		#needs to be enabled by default now
		$tool_simple->set_active(TRUE);
		$advanced_settings->set_sensitive(TRUE);
	}

	$tooltips->set_tip( $tool_simple,
		$d->get("The simple selection tool is the fastest way of taking a screenshot.\nIt provides an optional zoom window for precise shots.") );

	$menu_sel->show_all;

	return $menu_sel;
}

sub fct_ret_program_menu {

	my $icontheme     = Gtk2::IconTheme->get_for_screen( Gtk2::Gdk::Screen->get_default );
	my $menu_programs = Gtk2::Menu->new;

	#take $key (mime) directly
	my $key = &fct_get_current_file(undef);

	#search selected files for mime...
	unless ($key) {

		#no iconview ??
		return $menu_programs unless $session_start_screen{'first_page'}->{'view'};
		$session_start_screen{'first_page'}->{'view'}->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter = $session_start_screen{'first_page'}->{'model'}->get_iter($path);
				if ( defined $iter ) {
					$key = $session_start_screen{'first_page'}->{'model'}->get_value( $iter, 2 );
				}
			}
		);
	}

	#still no key? => leave sub
	return $menu_programs unless $key;

	#	my $mime_type = Gnome2::VFS::Mime::Type->new ($session_screens{$key}->{'mime_type'});
	#	my @apps = $mime_type->get_all_applications_for_uri( $session_screens{$key}->{'uri'} );

	#FIXME
	#cannot get icon with GnomeVFS
	#libgnomevfs-WARNING **:
	#Cannot call gnome_vfs_mime_application_get_icon
	#with a GNOMEVFSMimeApplication structure
	#constructed by the deprecated application registry
	return $menu_programs unless exists $session_screens{$key}->{'mime_type'};

	my ( $default, @apps ) = mime_applications( $session_screens{$key}->{'mime_type'} );
	foreach my $app (@apps) {

		my $program_item = Gtk2::ImageMenuItem->new_with_label( $app->Name );
		if ( $icontheme->has_icon( $app->Icon ) ) {
			my ( $iw, $ih ) = Gtk2::IconSize->lookup('menu');
			my $icon_pixbuf = $icontheme->load_icon( $app->Icon, $ih, 'generic-fallback' );
			$program_item->set_image( Gtk2::Image->new_from_pixbuf($icon_pixbuf) );
		}
		$program_item->signal_connect(
			'activate' => sub {
				&fct_open_with_program($app);
			}
		);

		$menu_programs->append($program_item);
	}

	$menu_programs->show_all;
	return $menu_programs;
}

sub fct_ret_web_menu {
	my $menu_web = Gtk2::Menu->new;
	my $timeout1 = Gtk2::RadioMenuItem->new( undef, $d->get("Timeout") . ": 5" );
	my $timeout2 = Gtk2::RadioMenuItem->new( $timeout1, $d->get("Timeout") . ": 10" );
	my $timeout3 = Gtk2::RadioMenuItem->new( $timeout1, $d->get("Timeout") . ": 15" );
	$timeout2->set_active(TRUE);
	$menu_web->append($timeout1);
	$menu_web->append($timeout2);
	$menu_web->append($timeout3);

	if ( defined $settings_xml->{'general'}->{'web_timeout'} ) {

		#determining timeout
		my @timeouts = $menu_web->get_children;
		my $timeout  = undef;
		foreach (@timeouts) {
			$timeout = $_->get_children->get_text;
			$timeout =~ /([0-9]+)/;
			$timeout = $1;
			if ( $settings_xml->{'general'}->{'web_timeout'} == $timeout ) {
				$_->set_active(TRUE);
			}
		}
	}
	$menu_web->show_all;
	return $menu_web;
}

sub fct_ret_profile_menu {
	my $combobox_settings_profiles = shift;
	my $current_profiles_ref       = shift;

	my $menu_profile = Gtk2::Menu->new;

	my $group   = undef;
	my $counter = 0;
	foreach my $profile ( @{$current_profiles_ref} ) {
		my $profile_item = Gtk2::RadioMenuItem->new( $group, $profile );
		$profile_item->set_active(TRUE)
			if $profile eq $combobox_settings_profiles->get_active_text;
		$profile_item->signal_connect(
			'toggled' => sub {
				my $widget = shift;
				return TRUE unless $widget->get_active;

				for ( my $i = 0; $i < scalar @{$current_profiles_ref}; $i++ ) {
					$combobox_settings_profiles->set_active($i);
					$current_profile_indx = $i;
					if ( $profile eq $combobox_settings_profiles->get_active_text ) {
						&evt_apply_profile( $widget, $combobox_settings_profiles, $current_profiles_ref );
						last;
					}
				}
			}
		);
		$group = $profile_item unless $group;
		$menu_profile->append($profile_item);
		$counter++;
	}

	$menu_profile->show_all;
	return $menu_profile;
}

sub fct_load_accounts_tree {

	$accounts_model
		= Gtk2::ListStore->new( 'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String' );

	foreach ( keys %accounts ) {
		my $hidden_text = "";
		for ( my $i = 1; $i <= length( $accounts{$_}->{'password'} ); $i++ ) {
			$hidden_text .= '*';
		}
		$accounts_model->set(
			$accounts_model->append, 0, $accounts{$_}->{'host'},     1, $accounts{$_}->{'username'},       2,
			$hidden_text,            3, $accounts{$_}->{'register'}, 4, $accounts{$_}->{'register_color'}, 5,
			$accounts{$_}->{'register_text'}
		);
	}

	return TRUE;
}

sub fct_load_plugin_tree {

	$effects_model = Gtk2::ListStore->new(
		'Gtk2::Gdk::Pixbuf', 'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String',
		'Glib::String',      'Glib::String', 'Glib::String'
	);
	foreach ( sort keys %plugins ) {
		if ( $plugins{$_}->{'binary'} ) {

			#check if plugin can handle png and/or jpeg
			$plugins{$_}->{'pixbuf_jpeg'} = 'gtk-no';
			$plugins{$_}->{'pixbuf_png'}  = 'gtk-no';
			$plugins{$_}->{'pixbuf_jpeg'} = 'gtk-yes'
				if ( $plugins{$_}->{'ext'} =~ /jpeg/ );
			$plugins{$_}->{'pixbuf_png'} = 'gtk-yes'
				if ( $plugins{$_}->{'ext'} =~ /png/ );

			#pixbuf
			$plugins{$_}->{'pixbuf'} = $plugins{$_}->{'binary'} . ".png"
				if ( $gscrot_hfunct->file_exists( $plugins{$_}->{'binary'} . ".png" ) );
			$plugins{$_}->{'pixbuf'} = $plugins{$_}->{'binary'} . ".svg"
				if ( $gscrot_hfunct->file_exists( $plugins{$_}->{'binary'} . ".svg" ) );

			if ( $gscrot_hfunct->file_exists( $plugins{$_}->{'pixbuf'} ) ) {
				$plugins{$_}->{'pixbuf_object'}
					= Gtk2::Gdk::Pixbuf->new_from_file_at_size( $plugins{$_}->{'pixbuf'}, Gtk2::IconSize->lookup('menu') );
			} else {
				$plugins{$_}->{'pixbuf'} = "$gscrot_root/share/gscrot/resources/icons/executable.svg";
				$plugins{$_}->{'pixbuf_object'}
					= Gtk2::Gdk::Pixbuf->new_from_file_at_size( $plugins{$_}->{'pixbuf'}, Gtk2::IconSize->lookup('menu') );
			}

			$effects_model->set(
				$effects_model->append,     0, $plugins{$_}->{'pixbuf_object'}, 1, $plugins{$_}->{'name'},       2,
				$plugins{$_}->{'category'}, 3, $plugins{$_}->{'pixbuf_jpeg'},   4, $plugins{$_}->{'pixbuf_png'}, 5,
				$plugins{$_}->{'tooltip'},  6, $plugins{$_}->{'lang'},          7, $plugins{$_}->{'binary'},     8,
				$_,
			);
		} else {
			print "\nWARNING: Plugin $_ is not configured properly, ignoring\n";
			delete $plugins{$_};
		}
	}

	return TRUE;
}

sub fct_set_model_accounts {
	my $accounts_tree = $_[0];

	my @columns = $accounts_tree->get_columns;
	foreach (@columns) {
		$accounts_tree->remove_column($_);
	}

	#host
	my $tv_clmn_name_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_name_text->set_title( $d->get("Host") );
	my $renderer_name_accounts = Gtk2::CellRendererText->new;
	$tv_clmn_name_text->pack_start( $renderer_name_accounts, FALSE );
	$tv_clmn_name_text->set_attributes( $renderer_name_accounts, text => 0 );
	$accounts_tree->append_column($tv_clmn_name_text);

	my $renderer_username_accounts = Gtk2::CellRendererText->new;
	$renderer_username_accounts->set( editable => TRUE );
	$renderer_username_accounts->signal_connect(
		'editing-started' => sub {
			my ( $cell, $cell_editable, $text_path, $model ) = @_;
			my $path = Gtk2::TreePath->new_from_string($text_path);
			my $iter = $model->get_iter($path);
			if ( $model->get_value( $iter, 0 ) =~ /imageshack/i ) {
				$gscrot_dialog->dlg_info_message(
					$d->get(
						"If you have registered with imageshack.us, you should have received an email with a link similar to\n\nhttp://reg.imageshack.us/setlogin.php?login=SOME_IDENTIFIER\n\nYou should pass either that link as the username or only the user_id (SOME_IDENTIFIER)\n\nYou do not have to provide a password."
					),
					"Imageshack info"
				);
			}
		},
		$accounts_model
	);
	$renderer_username_accounts->signal_connect(
		'edited' => sub {
			my ( $cell, $text_path, $new_text, $model ) = @_;
			my $path = Gtk2::TreePath->new_from_string($text_path);
			my $iter = $model->get_iter($path);

			#save entered username to the hash
			$accounts{ $model->get_value( $iter, 0 ) }->{'username'} = $new_text;

			if ( $model->get_value( $iter, 0 ) =~ /imageshack/i ) {

				#we catch the user-id when url is entered
				if ( $new_text =~ /^http.*login=(.*)/ ) {
					$new_text = $1;
				}

				#imageshack does not need a password
				$accounts{ $model->get_value( $iter, 0 ) }->{'password'} = $new_text;
			}

			$model->set( $iter, 1, $new_text );
		},
		$accounts_model
	);
	my $tv_clmn_username_text = Gtk2::TreeViewColumn->new_with_attributes( $d->get("Username"), $renderer_username_accounts, text => 1 );
	$tv_clmn_username_text->set_max_width(100);
	$accounts_tree->append_column($tv_clmn_username_text);

	#password
	my $tv_clmn_password_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_password_text->set_max_width(100);
	$tv_clmn_password_text->set_title( $d->get("Password") );
	my $renderer_password_accounts = Gtk2::CellRendererText->new;
	$renderer_password_accounts->set( editable => TRUE );
	$renderer_password_accounts->signal_connect(
		'editing-started' => sub {
			my ( $cell, $cell_editable, $text_path, $model ) = @_;
			my $path = Gtk2::TreePath->new_from_string($text_path);
			my $iter = $model->get_iter($path);
			if ( $model->get_value( $iter, 0 ) =~ /imageshack/i ) {
				$gscrot_dialog->dlg_info_message(
					$d->get(
						"If you have registered with imageshack.us, you should have received an email with a link similar to\n\nhttp://reg.imageshack.us/setlogin.php?login=SOME_IDENTIFIER\n\nYou should pass either that link as the username or only the user_id (SOME_IDENTIFIER)\n\nYou do not have to provide a password."
					),
					"Imageshack info"
				);
			}
		},
		$accounts_model
	);

	$renderer_password_accounts->signal_connect(
		edited => sub {
			my ( $cell, $text_path, $new_text, $model ) = @_;
			my $path        = Gtk2::TreePath->new_from_string($text_path);
			my $iter        = $model->get_iter($path);
			my $hidden_text = "";

			for ( my $i = 1; $i <= length($new_text); $i++ ) {
				$hidden_text .= '*';
			}
			unless ( $model->get_value( $iter, 0 ) =~ /imageshack/i ) {
				$accounts{ $model->get_value( $iter, 0 ) }->{'password'} = $new_text;    #save entered password to the hash
				$model->set( $iter, 2, $hidden_text );
			} else {
				$model->set( $iter, 2, "" );
			}
		},
		$accounts_model
	);

	$tv_clmn_password_text->pack_start( $renderer_password_accounts, FALSE );
	$tv_clmn_password_text->set_attributes( $renderer_password_accounts, text => 2 );
	$accounts_tree->append_column($tv_clmn_password_text);

	#register
	my $tv_clmn_pix_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_pix_text->set_title( $d->get("Register") );
	my $ren_text = Gtk2::CellRendererText->new();
	$tv_clmn_pix_text->pack_start( $ren_text, FALSE );
	$tv_clmn_pix_text->set_attributes( $ren_text, 'text', ( $d->get(5) ), 'foreground', 4 );
	$accounts_tree->append_column($tv_clmn_pix_text);

	return TRUE;
}

sub fct_set_model_plugins {
	my $effects_tree = $_[0];

	my @columns = $effects_tree->get_columns;
	foreach (@columns) {
		$effects_tree->remove_column($_);
	}

	#icon
	$effects_tree->set_tooltip_column(5)
		if Gtk2->CHECK_VERSION( 2, 11, 0 );
	my $tv_clmn_pix_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_pix_text->set_resizable(TRUE);
	$tv_clmn_pix_text->set_title( $d->get("Icon") );
	my $renderer_pix_effects = Gtk2::CellRendererPixbuf->new;
	$tv_clmn_pix_text->pack_start( $renderer_pix_effects, FALSE );
	$tv_clmn_pix_text->set_attributes( $renderer_pix_effects, pixbuf => 0 );
	$effects_tree->append_column($tv_clmn_pix_text);

	#name
	my $tv_clmn_text_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_text_text->set_resizable(TRUE);
	$tv_clmn_text_text->set_title( $d->get("Name") );
	my $renderer_text_effects = Gtk2::CellRendererText->new;
	$tv_clmn_text_text->pack_start( $renderer_text_effects, FALSE );
	$tv_clmn_text_text->set_attributes( $renderer_text_effects, text => 1 );

	$effects_tree->append_column($tv_clmn_text_text);

	#category
	my $tv_clmn_category_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_category_text->set_resizable(TRUE);
	$tv_clmn_category_text->set_title( $d->get("Category") );
	my $renderer_category_effects = Gtk2::CellRendererText->new;
	$tv_clmn_category_text->pack_start( $renderer_category_effects, FALSE );
	$tv_clmn_category_text->set_attributes( $renderer_category_effects, text => 2 );
	$effects_tree->append_column($tv_clmn_category_text);

	#jpeg
	my $tv_clmn_jpeg_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_jpeg_text->set_resizable(TRUE);
	$tv_clmn_jpeg_text->set_title("jpeg");
	my $renderer_jpeg_effects = Gtk2::CellRendererPixbuf->new;
	$tv_clmn_jpeg_text->pack_start( $renderer_jpeg_effects, FALSE );
	$tv_clmn_jpeg_text->set_attributes( $renderer_jpeg_effects, stock_id => 3 );
	$effects_tree->append_column($tv_clmn_jpeg_text);

	#png
	my $tv_clmn_png_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_png_text->set_resizable(TRUE);
	$tv_clmn_png_text->set_title("png");
	my $renderer_png_effects = Gtk2::CellRendererPixbuf->new;
	$tv_clmn_png_text->pack_start( $renderer_png_effects, FALSE );
	$tv_clmn_png_text->set_attributes( $renderer_png_effects, stock_id => 4 );
	$effects_tree->append_column($tv_clmn_png_text);

	#tooltip column
	unless ( Gtk2->CHECK_VERSION( 2, 12, 0 ) ) {
		my $tv_clmn_descr_text = Gtk2::TreeViewColumn->new;
		$tv_clmn_descr_text->set_resizable(TRUE);
		$tv_clmn_descr_text->set_title( $d->get("Description") );
		my $renderer_descr_effects = Gtk2::CellRendererText->new;
		$tv_clmn_descr_text->pack_start( $renderer_descr_effects, FALSE );
		$tv_clmn_descr_text->set_attributes( $renderer_descr_effects, text => 5 );
		$effects_tree->append_column($tv_clmn_descr_text);
	}

	#language
	my $tv_clmn_lang_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_lang_text->set_resizable(TRUE);
	$tv_clmn_lang_text->set_title( $d->get("Language") );
	my $renderer_lang_effects = Gtk2::CellRendererText->new;
	$tv_clmn_lang_text->pack_start( $renderer_lang_effects, FALSE );
	$tv_clmn_lang_text->set_attributes( $renderer_lang_effects, text => 6 );
	$effects_tree->append_column($tv_clmn_lang_text);

	#path
	my $tv_clmn_path_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_path_text->set_resizable(TRUE);
	$tv_clmn_path_text->set_title( $d->get("Path") );
	my $renderer_path_effects = Gtk2::CellRendererText->new;
	$tv_clmn_path_text->pack_start( $renderer_path_effects, FALSE );
	$tv_clmn_path_text->set_attributes( $renderer_path_effects, text => 7 );
	$effects_tree->append_column($tv_clmn_path_text);

	return TRUE;
}

sub fct_init_optional {

	print "INFO: searching for optional components...\n\n";
	if ( system("which gnome-web-photo") == 0 ) {
		print "SUCCESS: gnome-web-photo is installed on your system!\n\n";
	} else {
		warn "WARNING: gnome-web-photo is missing --> screenshots of websites will be disabled!\n\n";
		$gnome_web_photo = FALSE;
	}
	eval { require Gtk2::ImageView };
	if ($@) {
		warn "WARNING: Gtk2::ImageView is missing --> advanced seletion tool will be disabled!\n\n";
		$gtkimageview = FALSE;
	}
	eval { require Goo::Canvas };
	if ($@) {
		warn "WARNING: Goo::Canvas is missing --> drawing tool will be disabled!\n\n";
		$goocanvas = FALSE;
	}

	return TRUE;
}

sub fct_init {

	#are there any command line params?
	if ( @ARGV > 0 ) {
		foreach my $arg (@ARGV) {
			$arg =~ s/.{2}//;
			if ( $arg eq "debug" ) {
				$gscrot_common->set_debug(TRUE);
			} elsif ( $arg eq "help" ) {
				$gscrot_hfunct->usage;
				exit;
			} elsif ( $arg eq "clear_cache" ) {
				$gscrot_common->set_clear_cache(TRUE);
			} elsif ( $arg eq "min_at_startup" ) {
				$gscrot_common->set_min(TRUE);
			} elsif ( $arg eq "disable_systray" ) {
				$gscrot_common->set_disable_systray(TRUE);
			} elsif ( $arg eq "section" ) {

				#is there already a process of gscrot running?
				my @gscrot_pids = `pidof -o $$ -x $gscrot_path`;
				foreach (@gscrot_pids) {
					kill RTMAX => $_;
					die;
				}
				$gscrot_common->set_start_with("section");
				$gscrot_common->set_min(TRUE);
			} elsif ( $arg eq "selection" ) {

				#is there already a process of gscrot running?
				my @gscrot_pids = `pidof -o $$ -x $gscrot_path`;
				foreach (@gscrot_pids) {
					kill RTMIN => $_;
					die;
				}
				$gscrot_common->set_start_with("select");
				$gscrot_common->set_min(TRUE);
			} elsif ( $arg eq "window" ) {

				#is there already a process of gscrot running?
				my @gscrot_pids = `pidof -o $$ -x $gscrot_path`;
				foreach (@gscrot_pids) {
					kill USR2 => $_;
					die;
				}
				$gscrot_common->set_start_with("window");
				$gscrot_common->set_min(TRUE);
			} elsif ( $arg eq "full" ) {

				#is there already a process of gscrot running?
				my @gscrot_pids = `pidof -o $$ -x $gscrot_path`;
				foreach (@gscrot_pids) {
					kill USR1 => $_;
					die;
				}
				$gscrot_common->set_start_with("raw");
				$gscrot_common->set_min(TRUE);
			} else {
				warn "ERROR: illegal command " . $arg . " \n\n";
				$gscrot_hfunct->usage;
				exit;
			}
			print "INFO: command " . $arg . " recognized!\n\n";
		}
	} else {
		print "INFO: no command line parameters set...\n\n";
	}

	#an old .gscrot file existing?
	unlink("$ENV{ 'HOME' }/.gscrot")
		if ( $gscrot_hfunct->file_exists("$ENV{ 'HOME' }/.gscrot") );

	#an old .gscrot/settings.conf file existing?
	unlink("$ENV{ 'HOME' }/.gscrot/settings.conf")
		if ( $gscrot_hfunct->file_exists("$ENV{ 'HOME' }/.gscrot/settings.conf") );

	#is there already a .gscrot folder?
	mkdir("$ENV{ 'HOME' }/.gscrot")
		unless ( -d "$ENV{ 'HOME' }/.gscrot" );

	#...and a profiles folder?
	mkdir "$ENV{'HOME'}/.gscrot/profiles"
		unless ( -d "$ENV{'HOME'}/.gscrot/profiles" );

	return TRUE;
}

sub fct_init_framework_versions {
	if ( $gscrot_common->get_debug ) {
		print "\nINFO: gathering system information...";
		print "\n";
		printf "Glib %s \n", $Glib::VERSION;
		printf "Gtk2 %s \n", $Gtk2::VERSION;
		print "\n";

		# The version info stuff appeared in 1.040.
		print "Glib built for "
			. join( ".", Glib->GET_VERSION_INFO )
			. ", running with "
			. join( ".", &Glib::major_version, &Glib::minor_version, &Glib::micro_version ) . "\n"
			if $Glib::VERSION >= 1.040;
		print "Gtk2 built for "
			. join( ".", Gtk2->GET_VERSION_INFO )
			. ", running with "
			. join( ".", &Gtk2::major_version, &Gtk2::minor_version, &Gtk2::micro_version ) . "\n"
			if $Gtk2::VERSION >= 1.040;
		print "\n";
	}
	return TRUE;
}

#--------------------------------------

#dialogs
#--------------------------------------

sub dlg_status_message {
	my ( $index, $status_text ) = @_;
	$statusbar->push( $index, $status_text );
	return TRUE;
}

sub dlg_rename {
	my ($key) = @_;

	my $input_dialog = Gtk2::MessageDialog->new( $window, [qw/modal destroy-with-parent/], 'other', 'none', undef );

	$input_dialog->set( 'image' => Gtk2::Image->new_from_stock( 'gtk-dialog-question', 'dialog' ) );

	$input_dialog->set( 'text' => $d->get( sprintf( "Rename image %s", "'$session_screens{$key}->{'short'}'" ) ) );

	$input_dialog->set( 'secondary-text' => $d->get("New filename") . ": " );

	#rename button
	my $rename_btn = Gtk2::Button->new_with_mnemonic( $d->get("_Rename") );
	$rename_btn->set_image( Gtk2::Image->new_from_stock( 'gtk-save-as', 'button' ) );
	$rename_btn->can_default(TRUE);

	$input_dialog->add_button( 'gtk-cancel', 10 );
	$input_dialog->add_action_widget( $rename_btn, 20 );

	$input_dialog->set_default_response(20);

	my $new_filename_hbox = Gtk2::HBox->new();
	my $new_filename      = Gtk2::Entry->new();
	$new_filename->set_activates_default(TRUE);

	#show just the name of the image
	$new_filename->set_text( $session_screens{$key}->{'name'} );

	$new_filename_hbox->pack_start_defaults($new_filename);
	$input_dialog->vbox->add($new_filename_hbox);
	$input_dialog->show_all;

	#run dialog
	my $input_response = $input_dialog->run;

	#handle user responses here
	if ( $input_response == 20 ) {

		my $new_name = $new_filename->get_text;
		$new_name = $session_screens{$key}->{'folder'} . "/" . $new_name . "." . $session_screens{$key}->{'filetype'};
		my $new_uri = Gnome2::VFS::URI->new($new_name);

		#filenames eq? -> nothing to do here
		unless ( $session_screens{$key}->{'long'} eq $new_name ) {

			#does the "renamed" file already exists?
			unless ( $gscrot_hfunct->file_exists($new_name) ) {

				#ok => rename it
				$session_screens{$key}->{'handle'}->cancel;
				rename( $session_screens{$key}->{'long'}, $new_name );
				&fct_update_tab( $key, undef, Gnome2::VFS::URI->new($new_name) );

				#setup a new filemonitor, so we get noticed if the file changed
				&fct_add_file_monitor($key);

			} else {

				#ask the user to replace the image
				#replace button
				my $replace_btn = Gtk2::Button->new_with_mnemonic( $d->get("_Replace") );
				$replace_btn->set_image( Gtk2::Image->new_from_stock( 'gtk-save-as', 'button' ) );

				my $response = $gscrot_dialog->dlg_question_message(
					$d->get(
						sprintf(
							"The image already exists in %s. Replacing it will overwrite its contents.", "'$session_screens{$key}->{'folder'}'"
						)
					),
					'gtk-cancel',
					undef, undef,
					$replace_btn,
					undef, undef,
					$d->get( sprintf( "An image named %s already exists. Do you want to replace it?", "'" . $new_uri->extract_short_name . "'" ) )
				);

				#rename == replace_btn was hit
				if ( $response == 40 ) {

					$session_screens{$key}->{'handle'}->cancel;
					rename( $session_screens{$key}->{'long'}, $new_name );
					&fct_update_tab( $key, undef, Gnome2::VFS::URI->new($new_name) );

					#setup a new filemonitor, so we get noticed if the file changed
					&fct_add_file_monitor($key);

					#maybe file is in session as well, need to set the handler again ;-)
					foreach my $searchkey ( keys %session_screens ) {
						next if $key eq $searchkey;
						if ( $session_screens{$searchkey}->{'long'} eq $new_name ) {
							$session_screens{$searchkey}->{'changed'} = TRUE;
							&fct_update_tab($searchkey);
						}
					}
					$input_dialog->destroy();
					return TRUE;
				}
				$input_dialog->destroy();
				return FALSE;
			}

		}
		$input_dialog->destroy();
		return TRUE;
	} else {
		$input_dialog->destroy();
		return FALSE;
	}
}

sub dlg_plugin {
	my (@file_to_plugin_keys) = @_;

	my $dlg_header    = $d->get("Choose a plugin");
	my $plugin_dialog = Gtk2::Dialog->new(
		$dlg_header,
		$window,
		[qw/modal destroy-with-parent/],
		'gtk-cancel'  => 'reject',
		'gtk-execute' => 'accept'
	);
	$plugin_dialog->set_default_response('accept');
	my $model = Gtk2::ListStore->new( 'Gtk2::Gdk::Pixbuf', 'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String' );

	foreach ( sort keys %plugins ) {

		#TODO hier mssen die neuen Mime types hinzugefgt werden
		#		next
		#			unless $plugins{$_}->{'ext'} =~ /$session_screens{$key}->{'filetype'}/;
		if ( $plugins{$_}->{'binary'} ne "" ) {

			$model->set(
				$model->append,           0, $plugins{$_}->{'pixbuf_object'}, 1, $plugins{$_}->{'name'},    2,
				$plugins{$_}->{'binary'}, 3, $plugins{$_}->{'lang'},          4, $plugins{$_}->{'tooltip'}, 5,
				$_
			);
		} else {
			print "WARNING: Program $_ is not configured properly, ignoring\n";
		}
	}
	my $plugin_label       = Gtk2::Label->new( $d->get("Plugin") . ":" );
	my $plugin_label_blank = Gtk2::Label->new();
	my $plugin             = Gtk2::ComboBox->new($model);
	my $plugin_descr       = Gtk2::Label->new;
	$plugin_descr->set_line_wrap(TRUE);
	$plugin_descr->set_width_chars(30);
	$plugin_descr->set_padding( 10, 10 );
	my $plugin_image       = Gtk2::Image->new;
	my $plugin_descr_frame = Gtk2::Frame->new( $d->get("Description") );
	$plugin_descr_frame->add($plugin_descr);
	my $plugin_hbox1 = Gtk2::HBox->new( FALSE, 5 );
	my $plugin_hbox2 = Gtk2::HBox->new( FALSE, 5 );
	$plugin_hbox2->set_border_width(10);

	$plugin->signal_connect(
		'changed' => sub {

			my $model       = $plugin->get_model();
			my $plugin_iter = $plugin->get_active_iter();

			if ($plugin_iter) {
				my $plugin_pixbuf = $model->get_value( $plugin_iter, 0 );
				my $plugin_name   = $model->get_value( $plugin_iter, 1 );
				my $plugin_value  = $model->get_value( $plugin_iter, 2 );
				my $plugin_lang   = $model->get_value( $plugin_iter, 3 );
				my $plugin_tip    = $model->get_value( $plugin_iter, 4 );
				my $plugin_key    = $model->get_value( $plugin_iter, 5 );

				$plugin_descr->set_text($plugin_tip);
				if ( $gscrot_hfunct->file_exists( $plugins{$plugin_key}->{'pixbuf'} ) ) {
					$plugin_image->set_from_pixbuf( Gtk2::Gdk::Pixbuf->new_from_file_at_size( $plugins{$plugin_key}->{'pixbuf'}, 100, 100 ) );
				}
			}
		},
		'changed'
	);
	my $renderer_pix = Gtk2::CellRendererPixbuf->new;
	$plugin->pack_start( $renderer_pix, FALSE );
	$plugin->add_attribute( $renderer_pix, pixbuf => 0 );
	my $renderer_text = Gtk2::CellRendererText->new;
	$plugin->pack_start( $renderer_text, FALSE );
	$plugin->add_attribute( $renderer_text, text => 1 );
	$plugin->set_active(0);

	$plugin_hbox1->pack_start_defaults($plugin);

	$plugin_hbox2->pack_start_defaults($plugin_image);
	$plugin_hbox2->pack_start_defaults($plugin_descr_frame);

	$plugin_dialog->vbox->add($plugin_hbox1);
	$plugin_dialog->vbox->add($plugin_hbox2);

	$plugin_dialog->show_all;

	my $plugin_response = $plugin_dialog->run;

	if ( $plugin_response eq "accept" ) {
		my $model        = $plugin->get_model();
		my $plugin_iter  = $plugin->get_active_iter();
		my $plugin_value = $model->get_value( $plugin_iter, 2 );
		my $plugin_name  = $model->get_value( $plugin_iter, 1 );
		my $plugin_lang  = $model->get_value( $plugin_iter, 3 );
		unless ( $plugin_value =~ /[a-zA-Z0-9]+/ ) {
			$gscrot_dialog->dlg_error_message( $d->get("No plugin specified"), $d->get("Failed") );
			return FALSE;
		}

		foreach my $key (@file_to_plugin_keys) {
			my $data = [ $plugin_value, $plugin_name, $plugin_lang, $key, $plugin_dialog ];
			&fct_execute_plugin( undef, $data );
		}

		$plugin_dialog->destroy();
		return TRUE;
	} else {
		$plugin_dialog->destroy();
		return FALSE;
	}
}

sub dlg_upload {
	my (@files_to_upload) = @_;

	return FALSE if @files_to_upload < 1;

	my $dlg_header = $d->get("Upload");
	my $hosting_dialog = Gtk2::Dialog->new( $dlg_header, $window, [qw/modal destroy-with-parent/] );

	my $cancel_button = $hosting_dialog->add_button( 'gtk-cancel',       'reject' );
	my $upload_button = $hosting_dialog->add_button( $d->get("_Upload"), 'accept' );
	$upload_button->set_image( Gtk2::Image->new_from_stock( 'gtk-go-up', 'button' ) );
	$hosting_dialog->set_default_response('accept');
	my $model = Gtk2::ListStore->new( 'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String' );

	foreach ( keys %accounts ) {

		#cut username so the dialog will not explode ;-)
		my $short_username = $accounts{$_}->{'username'};
		if ( length $accounts{$_}->{'username'} > 10 ) {
			$short_username = substr( $accounts{$_}->{'username'}, 0, 10 ) . "...";
		}

		$model->set( $model->append, 0, $accounts{$_}->{'host'}, 1, $accounts{$_}->{'username'}, 2, $accounts{$_}->{'password'}, 3, $short_username )
			if (
			( $_ =~ /imageshack/i && $accounts{$_}->{'username'} ne "" )
			|| (   $accounts{$_}->{'username'} ne ""
				&& $accounts{$_}->{'password'} ne "" )
			);
		$model->set( $model->append, 0, $accounts{$_}->{'host'}, 1, $d->get("Guest"), 2, "", 3, $d->get("Guest") );
	}

	my $hosting_image = Gtk2::Image->new;

	#set up account combobox
	my $hosting       = Gtk2::ComboBox->new($model);
	my $renderer_host = Gtk2::CellRendererText->new;
	$hosting->pack_start( $renderer_host, FALSE );
	$hosting->add_attribute( $renderer_host, text => 0 );
	my $renderer_username = Gtk2::CellRendererText->new;
	$hosting->pack_start( $renderer_username, FALSE );
	$hosting->add_attribute( $renderer_username, text => 3 );
	$hosting->signal_connect(
		'changed' => sub {

			my $model        = $hosting->get_model();
			my $hosting_iter = $hosting->get_active_iter();

			if ($hosting_iter) {
				my $hosting_host     = $model->get_value( $hosting_iter, 0 );
				my $hosting_username = $model->get_value( $hosting_iter, 1 );
				if ( $hosting_host =~ /imageshack/i ) {
					$hosting_image->set_from_pixbuf(
						Gtk2::Gdk::Pixbuf->new_from_file_at_scale( "$gscrot_root/share/gscrot/resources/icons/logo-imageshack.png", 200, 200, TRUE )
					);
				} elsif ( $hosting_host =~ /imagebanana/i ) {
					$hosting_image->set_from_pixbuf(
						Gtk2::Gdk::Pixbuf->new_from_file_at_scale( "$gscrot_root/share/gscrot/resources/icons/logo-imagebanana.png", 200, 200, TRUE )
					);
				} elsif ( $hosting_host =~ /ubuntu-pics/i ) {
					$hosting_image->set_from_pixbuf(
						Gtk2::Gdk::Pixbuf->new_from_file_at_scale( "$gscrot_root/share/gscrot/resources/icons/logo-ubuntu-pics.png", 200, 200, TRUE )
					);
				}

			}
		},
		'changed'
	);

	$hosting->set_active(0);

	#image hoster settings
	my $hosting_hbox1 = Gtk2::HBox->new( TRUE,  5 );
	my $hosting_hbox2 = Gtk2::HBox->new( FALSE, 5 );
	$hosting_hbox2->set_border_width(10);
	$hosting_hbox1->pack_start_defaults( Gtk2::Label->new( $d->get("Choose account") ) );
	$hosting_hbox1->pack_start_defaults($hosting);
	$hosting_hbox2->pack_start_defaults($hosting_image);

	#ftp settings
	#we are using the same widgets as in the settings and populate
	#them with saved values when possible

	my $ftp_hbox1_dlg = Gtk2::HBox->new( TRUE, 0 );
	my $ftp_hbox2_dlg = Gtk2::HBox->new( TRUE, 0 );
	my $ftp_hbox3_dlg = Gtk2::HBox->new( TRUE, 0 );
	my $ftp_hbox4_dlg = Gtk2::HBox->new( TRUE, 0 );

	#uri
	my $ftp_entry_label_dlg = Gtk2::Label->new( $d->get("URI") );
	$ftp_hbox1_dlg->pack_start( $ftp_entry_label_dlg, TRUE, TRUE, 10 );
	my $ftp_remote_entry_dlg = Gtk2::Entry->new;
	$ftp_remote_entry_dlg->set_text( $ftp_remote_entry->get_text );

	$tooltips->set_tip( $ftp_entry_label_dlg, $d->get("URI\nExample: ftp://host:port/path") );

	$tooltips->set_tip( $ftp_remote_entry_dlg, $d->get("URI\nExample: ftp://host:port/path") );

	$ftp_hbox1_dlg->pack_start( $ftp_remote_entry_dlg, TRUE, TRUE, 10 );

	#connection mode
	my $ftp_mode_label_dlg = Gtk2::Label->new( $d->get("Connection mode") );
	$ftp_hbox2_dlg->pack_start( $ftp_mode_label_dlg, TRUE, TRUE, 10 );
	my $ftp_mode_combo_dlg = Gtk2::ComboBox->new_text;
	$ftp_mode_combo_dlg->insert_text( 0, $d->get("Active mode") );
	$ftp_mode_combo_dlg->insert_text( 1, $d->get("Passive mode") );
	$ftp_mode_combo_dlg->set_active( $ftp_mode_combo->get_active );

	$tooltips->set_tip( $ftp_mode_label_dlg, $d->get("Connection mode") );

	$tooltips->set_tip( $ftp_mode_combo_dlg, $d->get("Connection mode") );

	$ftp_hbox2_dlg->pack_start( $ftp_mode_combo_dlg, TRUE, TRUE, 10 );

	#username
	my $ftp_username_label_dlg = Gtk2::Label->new( $d->get("Username") );
	$ftp_hbox3_dlg->pack_start( $ftp_username_label_dlg, TRUE, TRUE, 10 );
	my $ftp_username_entry_dlg = Gtk2::Entry->new;
	$ftp_username_entry_dlg->set_text( $ftp_username_entry->get_text );

	$tooltips->set_tip( $ftp_username_label_dlg, $d->get("Username") );

	$tooltips->set_tip( $ftp_username_entry_dlg, $d->get("Username") );

	$ftp_hbox3_dlg->pack_start( $ftp_username_entry_dlg, TRUE, TRUE, 10 );

	#password
	my $ftp_password_label_dlg = Gtk2::Label->new( $d->get("Password") );
	$ftp_hbox4_dlg->pack_start( $ftp_password_label_dlg, TRUE, TRUE, 10 );
	my $ftp_password_entry_dlg = Gtk2::Entry->new;
	$ftp_password_entry_dlg->set_invisible_char("*");
	$ftp_password_entry_dlg->set_visibility(FALSE);
	$ftp_password_entry_dlg->set_text( $ftp_password_entry->get_text );

	$tooltips->set_tip( $ftp_password_label_dlg, $d->get("Password") );

	$tooltips->set_tip( $ftp_password_entry_dlg, $d->get("Password") );

	$ftp_hbox4_dlg->pack_start( $ftp_password_entry_dlg, TRUE, TRUE, 10 );

	my $ftp_vbox_dlg = Gtk2::VBox->new( TRUE, 0 );
	$ftp_vbox_dlg->pack_start( $ftp_hbox1_dlg, FALSE, TRUE, 1 );
	$ftp_vbox_dlg->pack_start( $ftp_hbox2_dlg, FALSE, TRUE, 1 );
	$ftp_vbox_dlg->pack_start( $ftp_hbox3_dlg, FALSE, TRUE, 1 );
	$ftp_vbox_dlg->pack_start( $ftp_hbox4_dlg, FALSE, TRUE, 1 );

	#default setting
	$hosting->set_sensitive(TRUE);
	$ftp_remote_entry_dlg->set_sensitive(FALSE);
	$ftp_mode_combo_dlg->set_sensitive(FALSE);
	$ftp_username_entry_dlg->set_sensitive(FALSE);
	$ftp_password_entry_dlg->set_sensitive(FALSE);

	#handle radiobuttons
	my $radio_imagehoster = Gtk2::RadioButton->new( undef, $d->get("Upload file to hosting-site") );
	$radio_imagehoster->signal_connect(
		'clicked' => sub {
			$hosting->set_sensitive(TRUE);
			$ftp_remote_entry_dlg->set_sensitive(FALSE);
			$ftp_mode_combo_dlg->set_sensitive(FALSE);
			$ftp_username_entry_dlg->set_sensitive(FALSE);
			$ftp_password_entry_dlg->set_sensitive(FALSE);
		}
	);

	my $radio_ftp = Gtk2::RadioButton->new( $radio_imagehoster, $d->get("Upload file via FTP") );
	$radio_ftp->signal_connect(
		'clicked' => sub {
			$hosting->set_sensitive(FALSE);
			$ftp_remote_entry_dlg->set_sensitive(TRUE);
			$ftp_mode_combo_dlg->set_sensitive(TRUE);
			$ftp_username_entry_dlg->set_sensitive(TRUE);
			$ftp_password_entry_dlg->set_sensitive(TRUE);
		}
	);

	#final packing
	$hosting_dialog->vbox->add($radio_imagehoster);
	$hosting_dialog->vbox->add($hosting_hbox1);
	$hosting_dialog->vbox->add($hosting_hbox2);

	$hosting_dialog->vbox->add($radio_ftp);
	$hosting_dialog->vbox->add($ftp_vbox_dlg);

	my $hosting_progress = Gtk2::ProgressBar->new;
	$hosting_progress->set_no_show_all(TRUE);
	$hosting_progress->set_ellipsize('middle');
	$hosting_progress->set_orientation('left-to-right');
	$hosting_dialog->vbox->add($hosting_progress);

	$hosting_dialog->show_all;
UPDIALOG: while ($hosting_dialog) {

		#initial state of dialog
		$upload_button->set_sensitive(TRUE);
		$cancel_button->set_sensitive(TRUE);
		$hosting_progress->hide;

		#DIALOG RUN
		my $hosting_response = $hosting_dialog->run;

		#running state of dialog
		$upload_button->set_sensitive(FALSE);
		$cancel_button->set_sensitive(FALSE);
		$hosting_progress->show;

		#start upload
		if ( $hosting_response eq "accept" ) {

			#imagehosting
			if ( $radio_imagehoster->get_active ) {
				my $model            = $hosting->get_model();
				my $hosting_iter     = $hosting->get_active_iter();
				my $hosting_host     = $model->get_value( $hosting_iter, 0 );
				my $hosting_username = $model->get_value( $hosting_iter, 1 );
				my $hosting_password = $model->get_value( $hosting_iter, 2 );
				if ( $hosting_host eq "ubuntu-pics.de" ) {
					my $uploader
						= GScrot::Upload::UbuntuPics->new( $hosting_host, $gscrot_common->get_debug, $gscrot_root, $d, $window, GSCROT_VERSION );
					my $counter = 1;
					$hosting_progress->set_fraction(0);
					foreach my $file ( sort @files_to_upload ) {
						$hosting_progress->set_text($file);

						#update gui
						&fct_update_gui;
						my %upload_response = $uploader->upload( $gscrot_hfunct->switch_home_in_file($file), $hosting_username, $hosting_password );

						if ( is_success( $upload_response{'status'} ) ) {
							$uploader->show;
							&dlg_status_message( 1, $file . " " . $d->get("uploaded") );
						} else {
							my $response = &dlg_upload_error_message( $upload_response{'status'}, $upload_response{'max_filesize'} );

							#10 == skip all, 20 == skip, else == cancel
							last if $response == 10;
							next if $response == 20;
							redo if $response == 30;
							next UPDIALOG;
						}
						$hosting_progress->set_fraction( $counter / @files_to_upload );

						#update gui
						&fct_update_gui;
						$counter++;
					}
					$uploader->show_all;
				} elsif ( $hosting_host eq "imagebanana.com" ) {
					my $uploader
						= GScrot::Upload::ImageBanana->new( $hosting_host, $gscrot_common->get_debug, $gscrot_root, $d, $window, GSCROT_VERSION );
					my $counter = 1;
					$hosting_progress->set_fraction(0);
					foreach my $file (@files_to_upload) {
						$hosting_progress->set_text($file);

						#update gui
						&fct_update_gui;
						my %upload_response = $uploader->upload( $gscrot_hfunct->switch_home_in_file($file), $hosting_username, $hosting_password );

						if ( is_success( $upload_response{'status'} ) ) {
							$uploader->show;
							&dlg_status_message( 1, $file . " " . $d->get("uploaded") );
						} else {
							my $response = &dlg_upload_error_message( $upload_response{'status'}, $upload_response{'max_filesize'} );

							#10 == skip all, 20 == skip, else == cancel
							last if $response == 10;
							next if $response == 20;
							redo if $response == 30;
							next UPDIALOG;
						}
						$hosting_progress->set_fraction( $counter / @files_to_upload );

						#update gui
						&fct_update_gui;
						$counter++;
					}
					$uploader->show_all;
				} elsif ( $hosting_host eq "imageshack.us" ) {
					my $ishack = GScrot::Upload::ImageShack->new();

					#upload
					my $counter = 1;
					$hosting_progress->set_fraction(0);
					foreach my $file (@files_to_upload) {

						#login
						eval { $ishack->login($hosting_username); };
						if ($@) {
							my $response = $gscrot_dialog->dlg_error_message( $d->get("Please check your credentials and try again."),
								$d->get("Login failed!") );

							next UPDIALOG;
						}

						$hosting_progress->set_text($file);

						#update gui
						&fct_update_gui;
						my $url = undef;
						eval { $url = $ishack->host( $file, undef ); };
						if ($@) {
							my $response = $gscrot_dialog->dlg_error_message(
								$d->get("Please check your connectivity and try again."),
								$d->get("Connection error!"),
								$d->get("Skip all"), $d->get("Skip"), 'gtk-redo'
							);

							#10 == skip all, 20 == skip, else == cancel
							last if $response == 10;
							next if $response == 20;
							redo if $response == 30;
							next UPDIALOG;
						}

						#get thumbnail url
						my $thumb_url = undef;
						eval { $thumb_url = $ishack->hosted_thumb; };

						if ($url) {
							$ishack->show( $hosting_host, $hosting_username, $file, $url, $thumb_url, RC_OK, $d, $window, $gscrot_root );
							&dlg_status_message( 1, $file . " " . $d->get("uploaded") );
						} else {
							my $response = $gscrot_dialog->dlg_error_message(
								$d->get("Please check your connectivity and try again."),
								$d->get("Connection error!"),
								$d->get("Skip all"), $d->get("Skip"), 'gtk-redo'
							);

							#10 == skip all, 20 == skip, else == cancel
							last if $response == 10;
							next if $response == 20;
							redo if $response == 30;
							next UPDIALOG;
						}
						$hosting_progress->set_fraction( $counter / @files_to_upload );

						#update gui
						&fct_update_gui;
						$counter++;
					}
					$ishack->show_all;
				}

				#ftp
			} elsif ( $radio_ftp->get_active ) {

				#create upload object
				my $uploader = GScrot::Upload::FTP->new( $gscrot_common->get_debug, $gscrot_root, $d, $window, $ftp_mode_combo_dlg->get_active );

				my $counter = 1;
				my $login   = FALSE;
				$hosting_progress->set_fraction(0);

				#start upload
				foreach my $file (@files_to_upload) {

					#need to login?
					my $upload_response;
					unless ($login) {

						eval { $uploader->quit; };

						$upload_response = $uploader->login( $ftp_remote_entry_dlg->get_text, $ftp_username_entry_dlg->get_text,
							$ftp_password_entry_dlg->get_text );

						if ($upload_response) {

							#we already get translated error messaged back
							my $response = $gscrot_dialog->dlg_error_message( $upload_response, $d->get("Failed") );
							next UPDIALOG;
						} else {
							$login = TRUE;
						}

						$hosting_progress->set_text($upload_response);

					}

					$hosting_progress->set_text($file);

					#update gui
					&fct_update_gui;
					$upload_response = $uploader->upload( $gscrot_hfunct->switch_home_in_file($file) );

					#upload returns FALSE if there is no error
					unless ($upload_response) {

						#everything is fine here
						&dlg_status_message( 1, $file . " " . $d->get("uploaded") );
					} else {

						#we already get translated error messaged back
						my $response = $gscrot_dialog->dlg_error_message( $upload_response, $d->get("Failed"), $d->get("Skip all"), $d->get("Skip"),
							'gtk-redo' );

						#10 == skip all, 20 == skip, 30 == redo, else == cancel
						if ( $response == 10 ) {
							last;
						} elsif ( $response == 20 ) {
							$login = FALSE;
							next;
						} elsif ( $response == 30 ) {
							$login = FALSE;
							redo;
						} else {
							next UPDIALOG;
						}

					}
					$hosting_progress->set_fraction( $counter / @files_to_upload );

					#update gui
					&fct_update_gui;
					$counter++;
				}    #end foreach
				$uploader->quit;
			}

			$hosting_dialog->destroy();
			return TRUE;
		} else {
			$hosting_dialog->destroy();
			return FALSE;
		}    #if response == accept

	}    #dialog loop
}

sub dlg_upload_error_message {
	my ( $status, $max_filesize ) = @_;

	my $response;
	if ( $status == 999 ) {
		$response = $gscrot_dialog->dlg_error_message( $d->get("Please check your credentials and try again."), $d->get("Login failed!") );
	} elsif ( $status == 998 ) {
		$response = $gscrot_dialog->dlg_error_message( $d->get("Maximum filesize reached!") . " ( $max_filesize )",
			$d->get("Failed"), $d->get("Skip all"), $d->get("Skip") );
	} else {
		$response = $gscrot_dialog->dlg_error_message(
			$d->get("Please check your connectivity and try again."),
			$d->get("Connection error!") . " (" . $status . ")",
			$d->get("Skip all"), $d->get("Skip"), 'gtk-redo'
		);
	}
	return $response;
}

sub dlg_website {
	my ( $filename, $filetype_value, $quality_value ) = @_;

	my $screenshot  = 5;
	my $web_process = Proc::Simple->new;

	my $website_dialog = Gtk2::MessageDialog->new( $window, [qw/modal destroy-with-parent/], 'other', 'none', undef );

	$website_dialog->set( 'text' => $d->get("Take a screenshot of a website") );

	$website_dialog->set( 'secondary-text' => $d->get("URL to capture") . ": " );

	$website_dialog->set(
		'image' => Gtk2::Image->new_from_pixbuf(
			Gtk2::Gdk::Pixbuf->new_from_file_at_size( "$gscrot_root/share/gscrot/resources/icons/web_image.svg", Gtk2::IconSize->lookup('dialog') )
		)
	);

	#cancel button
	my $cancel_btn = Gtk2::Button->new_from_stock('gtk-cancel');

	#save button
	my $execute_btn = Gtk2::Button->new_from_stock('gtk-execute');
	$execute_btn->can_default(TRUE);

	$website_dialog->add_action_widget( $cancel_btn,  'cancel' );
	$website_dialog->add_action_widget( $execute_btn, 'accept' );

	$website_dialog->set_default_response('accept');

	my $website_hbox  = Gtk2::HBox->new();
	my $website_hbox2 = Gtk2::HBox->new();

	my $website = Gtk2::Entry->new;
	$website->set_text("http://");
	$website->set_activates_default(TRUE);
	my $clipboard_string = $clipboard->wait_for_text;
	print "Content of clipboard is: $clipboard_string\n"
		if $gscrot_common->get_debug;

	if ( defined $clipboard_string ) {
		if (   $clipboard_string =~ /^http/
			|| $clipboard_string =~ /^file/
			|| $clipboard_string =~ /^www\./ )
		{
			$website->set_text($clipboard_string);
		}
	}

	$website_hbox->pack_start( $website, TRUE, TRUE, 12 );
	$website_dialog->vbox->add($website_hbox);

	my $website_progress = Gtk2::ProgressBar->new;
	$website_progress->set_no_show_all(TRUE);
	$website_progress->set_ellipsize('middle');
	$website_progress->set_orientation('left-to-right');
	$website_progress->set_fraction(0);
	$website_hbox2->pack_start( $website_progress, TRUE, TRUE, 12 );
	$website_dialog->vbox->add($website_hbox2);

	$website_dialog->show_all;
	my $website_response = $website_dialog->run;

	if ( $website_response eq "accept" ) {

		$execute_btn->set_sensitive(FALSE);

		#show progress bar while executing gnome-web-photo
		$website_progress->show;
		&fct_update_gui;

		my $url      = $website->get_text;
		my $hostname = $url;
		$hostname =~ s/http:\/\///;

		if ( $hostname eq "" ) {
			$gscrot_dialog->dlg_error_message( $d->get("No valid url entered"), $d->get("Failed") );
			$website_dialog->destroy();
			return $screenshot;
		}

		#determining timeout
		my $web_menu = $gscrot_tool->{_web}->get_menu;
		my @timeouts = $web_menu->get_children;
		my $timeout  = undef;
		foreach (@timeouts) {
			if ( $_->get_active ) {
				$timeout = $_->get_children->get_text;
				$timeout =~ /([0-9]+)/;
				$timeout = $1;
				print $timeout. "\n" if $gscrot_common->get_debug;
			}
		}

		my $screenshooter = GScrot::Screenshot::Web->new( $timeout, $filetype_value, $quality_value, $url, $filename );

		Proc::Simple::debug(1) if $gscrot_common->get_debug;

		$web_process->start(
			sub {
				$screenshooter->web();
				POSIX::_exit(0);
			}
		);

		$cancel_btn->signal_connect(
			'clicked' => sub {
				if ( $web_process->kill() ) {

					#delete file if process was cancelled
					unlink("$filename");
					$website_dialog->destroy();
				}
			}
		);

		while ( $web_process->poll ) {
			$website_progress->pulse;
			&fct_update_gui;
			usleep 100000;
		}

		#we cannot kill the process anymore
		#closing the dialog will confuse the user
		#because the image will appear in the session later on
		$cancel_btn->set_sensitive(FALSE);
		&fct_update_gui;

		if ( $web_process->exit_status() == 0 ) {

			$website_progress->set_fraction( 2 / 3 );
			&fct_update_gui;

			eval { $screenshot = Gtk2::Gdk::Pixbuf->new_from_file($filename) };
			if ($@) {

				#error when loading file
				$screenshot = 0;
				unlink($filename);
				$website_dialog->destroy();
			}

			$website_progress->set_fraction( 3 / 3 );
			&fct_update_gui;

		}

		$website_dialog->destroy();

		return $screenshot;
	} else {
		$website_dialog->destroy();

		return $screenshot;
	}
}

sub dlg_profile_name {
	my ( $curr_profile_name, $combobox_settings_profiles ) = @_;
	my $dlg_header     = $d->get("Save as profile");
	my $profile_dialog = Gtk2::Dialog->new(
		$dlg_header,
		$window, [qw/modal destroy-with-parent/],
		'gtk-cancel' => 'reject',
		'gtk-save'   => 'accept'
	);
	$profile_dialog->set_default_response('accept');

	my $new_profile_name_hbox  = Gtk2::HBox->new();
	my $new_profile_name_label = Gtk2::Label->new( $d->get("Profile") . ": " );
	my $new_profile_name       = Gtk2::Entry->new();
	$new_profile_name->set_activates_default(TRUE);
	$new_profile_name->set_text($curr_profile_name)
		if defined $curr_profile_name;
	$new_profile_name_hbox->pack_start_defaults($new_profile_name_label);
	$new_profile_name_hbox->pack_start_defaults($new_profile_name);
	$profile_dialog->vbox->add($new_profile_name_hbox);
	$profile_dialog->show_all;
	my $profile_response = $profile_dialog->run;

	if ( $profile_response eq "accept" ) {
		my $entered_name = $new_profile_name->get_text;

		if ( $gscrot_hfunct->file_exists("$ENV{'HOME'}/.gscrot/profiles/$entered_name.xml") ) {

			if ( $gscrot_dialog->dlg_question_message( $d->get("Profile already exists.\nDo you want to overwrite the existing profile?") ) ) {
				$profile_dialog->destroy();
				return $new_profile_name->get_text;
			} else {
				$profile_dialog->destroy();
				return FALSE;
			}
		}

		$profile_dialog->destroy();
		return $new_profile_name->get_text;
	} else {
		$profile_dialog->destroy();
		return FALSE;
	}
}

#--------------------------------------

